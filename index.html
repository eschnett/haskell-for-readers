<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Joachim Breitner, DFINITY Foundation" />
  <title>Haskell for Readers</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <link rel="stylesheet" href="solution.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script defer="defer">
  function onload(){
    var elements = document.querySelectorAll(".Solution");
    function reveal() { this.classList.add("revealed"); }
    for (var i = 0; i < elements.length; i++) {
      elements[i].addEventListener("click", reveal);
    }
  };
  document.addEventListener( "DOMContentLoaded", onload, false );
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Haskell for Readers</h1>
<p class="author"><a href="http://www.joachim-breitner.de/">Joachim Breitner</a>, <a href="https://dfinity.org/">DFINITY Foundation</a></p>
</header>
<nav id="TOC">
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#the-basics-of-functional-programming"><span class="toc-section-number">1</span> The basics of functional programming</a><ul>
<li><a href="#numbers-and-arithmetic-operators"><span class="toc-section-number">1.1</span> Numbers and arithmetic operators</a></li>
<li><a href="#applying-functions"><span class="toc-section-number">1.2</span> Applying Functions</a></li>
<li><a href="#booleans-and-branching"><span class="toc-section-number">1.3</span> Booleans and branching</a></li>
<li><a href="#function-abstraction"><span class="toc-section-number">1.4</span> Function abstraction</a></li>
<li><a href="#recursion"><span class="toc-section-number">1.5</span> Recursion</a></li>
<li><a href="#higher-order-functions"><span class="toc-section-number">1.6</span> Higher-order functions</a></li>
<li><a href="#anonymous-functions"><span class="toc-section-number">1.7</span> Anonymous functions</a></li>
<li><a href="#higher-order-function-definition"><span class="toc-section-number">1.8</span> Higher-order function definition</a></li>
<li><a href="#currying"><span class="toc-section-number">1.9</span> Currying</a></li>
<li><a href="#the-composition-operator"><span class="toc-section-number">1.10</span> The composition operator ★</a></li>
<li><a href="#laziness"><span class="toc-section-number">1.11</span> Laziness ★</a></li>
</ul></li>
<li><a href="#types"><span class="toc-section-number">2</span> Types</a><ul>
<li><a href="#tooling-interlude-editing-files"><span class="toc-section-number">2.1</span> Tooling interlude: Editing files ★</a></li>
<li><a href="#basic-types"><span class="toc-section-number">2.2</span> Basic types</a></li>
<li><a href="#polymorphism"><span class="toc-section-number">2.3</span> Polymorphism</a></li>
<li><a href="#constrained-types-a-first-glimpse"><span class="toc-section-number">2.4</span> Constrained types (a first glimpse)</a></li>
<li><a href="#parametricity"><span class="toc-section-number">2.5</span> Parametricity</a></li>
<li><a href="#algebraic-data-types"><span class="toc-section-number">2.6</span> Algebraic data types</a></li>
<li><a href="#predefined-data-types"><span class="toc-section-number">2.7</span> Predefined data types</a></li>
<li><a href="#records"><span class="toc-section-number">2.8</span> Records ★</a></li>
<li><a href="#newtypes"><span class="toc-section-number">2.9</span> Newtypes ★</a></li>
<li><a href="#type-synonyms"><span class="toc-section-number">2.10</span> Type synonyms ★</a></li>
<li><a href="#haddock"><span class="toc-section-number">2.11</span> Haddock ★</a></li>
</ul></li>
<li><a href="#code-structure-small-and-large"><span class="toc-section-number">3</span> Code structure small and large</a><ul>
<li><a href="#let-expressions"><span class="toc-section-number">3.1</span> <code>let</code>-expressions</a></li>
<li><a href="#where-clauses"><span class="toc-section-number">3.2</span> <code>where</code>-clauses ★</a></li>
<li><a href="#comments"><span class="toc-section-number">3.3</span> Comments ★</a></li>
<li><a href="#the-structure-of-a-module"><span class="toc-section-number">3.4</span> The structure of a module</a></li>
<li><a href="#importing-other-modules"><span class="toc-section-number">3.5</span> Importing other modules</a></li>
<li><a href="#import-lists"><span class="toc-section-number">3.6</span> Import lists ★</a></li>
<li><a href="#export-lists-and-abstract-types"><span class="toc-section-number">3.7</span> Export lists and abstract types ★</a></li>
<li><a href="#language-extensions"><span class="toc-section-number">3.8</span> Language extensions</a></li>
<li><a href="#haskell-packages"><span class="toc-section-number">3.9</span> Haskell packages ★</a></li>
</ul></li>
<li><a href="#type-classes"><span class="toc-section-number">4</span> Type classes</a><ul>
<li><a href="#overloading"><span class="toc-section-number">4.1</span> Overloading</a></li>
<li><a href="#implicit-dependency-injection"><span class="toc-section-number">4.2</span> Implicit dependency injection</a></li>
<li><a href="#polymorphism-over-types-with-structure"><span class="toc-section-number">4.3</span> Polymorphism over types with structure</a></li>
<li><a href="#type-driven-code-synthesis"><span class="toc-section-number">4.4</span> Type-driven code synthesis</a></li>
<li><a href="#interlude-kinds"><span class="toc-section-number">4.5</span> Interlude: Kinds ★</a></li>
<li><a href="#common-pre-defined-type-classes"><span class="toc-section-number">4.6</span> Common pre-defined type classes ★</a></li>
</ul></li>
<li><a href="#monads"><span class="toc-section-number">5</span> Monads</a><ul>
<li><a href="#imperative-code-with-do-notation"><span class="toc-section-number">5.1</span> Imperative code with <code>do</code> notation</a></li>
<li><a href="#monads-for-real"><span class="toc-section-number">5.2</span> Monads, for real</a></li>
</ul></li>
</ul>
</nav>
<p><a id="nav-toggle" href="#TOC"></a></p>
<section id="preface" class="level1 unnumbered">
<h1>Preface</h1>
<p>Welcome to the lecture series “Haskell for Readers”. This workshop is uniquely tailored to those who need to <em>read</em>, rather than <em>write</em> Haskell code: auditors, scientists, managers, testers etc.</p>
<section id="status" class="level3 unnumbered">
<h3>Status</h3>
<p>This document is work in progress (but whatever chapters and sections are there ought to be … usable).</p>
</section>
<section id="scope" class="level3 unnumbered">
<h3>Scope</h3>
<p>This goal implies a higher focus on syntax (because you can <em>write</em> programs ignoring most syntactic gadgets available to you, but if you read code, you have to deal with them), types and type signatures (because they are the key to understanding Haskell code) and abstraction patterns (because it is key to understanding well-written code, and Haskell excels at abstraction).</p>
<p>On the other hand, less words will be spent on how to approach writing the program, e.g. how to set up your tooling, how to please Haskell’s layout rules, how to design your data type, which libraries to pick, how to read error messages. That said, we hope that even Haskell programmers will gain useful insight from tutorial.</p>
<p>Nevertheless it is hard to understand a programming paradigm without writing any code, so there will some amount of hands-on work to be done, especially early on, when we start with a introduction to basic functional programming.</p>
</section>
<section id="form" class="level3 unnumbered">
<h3>Form</h3>
<p>This document is not (necessarily) a self-contained tutorial; it is rather the base for an interactive lecture, given by a real instructor. In such a lecture, some holes will be filled as we go, and the questions from the audience form a crucial part of the learning experience.</p>
<p>This document is also meant to be more on the concise side, assuming the audience is shorter on time than on wits, and in a small, live workshop, the lecturer can add details, come up with more examples and slow down as needed.</p>
<p>This makes these notes less ideal for independent study, but that said, it should be possible to work attentively through them and still learn a lot.</p>
</section>
<section id="audience" class="level3 unnumbered">
<h3>Audience</h3>
<p>I expect the audience to be familiar with programming and computer science in general, but do not assume prior knowledge of functional program (or, in case you are worried about this, category theory).</p>
<p>The exercises are all very small, in the order of minutes, and are meant to be done along the way, especially as later material may refer to their results. If you are reading this on your own and you really do not feel like doing them, you can click on the blurred solutions to at least read them. The exercises are not sufficient in number and depths to provide the reader the experience needed to really learn Haskell.</p>
<p>Some sections are marked with ★. These are optional in the sense that the following material does not rely heavily on them. If time is short, e.g. during a workshop, they can be skipped, and the participants can be invited to come back to them on their own.</p>
</section>
<section id="acknowledgments-and-license" class="level3 unnumbered">
<h3>Acknowledgments and license</h3>
<p>The creation of this material was sponsored by the <a href="http://dfinity.org/">DFINITY Foundation</a>, and is shared with the public under the terms of the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. You can view <a href="https://github.com/nomeata/haskell-for-readers/">the source on GitHub</a> of this document, and submit improvements there.</p>
</section>
</section>
<section id="the-basics-of-functional-programming" class="level1">
<h1><span class="header-section-number">1</span> The basics of functional programming</h1>
<p>Functional program is the the art of thinking about <em>data</em> and how the new data is calculated from old data, rather than thinking about how to <em>modify</em> data.</p>
<section id="numbers-and-arithmetic-operators" class="level2">
<h2><span class="header-section-number">1.1</span> Numbers and arithmetic operators</h2>
<p>The simplest form of data are numbers, and basic arithmetic is one way of creating new numbers from old numbers.</p>
<p>To play around with this, start the Haskell REPL (“read-eval-print-loop”) by running <code>ghci</code> (or maybe on <a href="https://tryhaskell.org/">tryhaskell.org</a>), and enter some numbers, and some of the usual arithmetic operations:</p>
<pre><code>$ ghci
GHCi, version 8.4.4: http://www.haskell.org/ghc/  :? for help
Prelude&gt; 1
1
Prelude&gt; 1 + 1
2
Prelude&gt; 2 + 3 * 4
14
Prelude&gt; (2 + 3) * 4
20</code></pre>
<p>At this point we can tell that the usual precedence rules apply (i.e. the <a href="https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics">PEMDAS rule</a>).</p>
<pre><code>Prelude&gt; 0 - 1
-1</code></pre>
<p>Numbers can be negative…</p>
<pre><code>Prelude&gt; 2^10
1024
Prelude&gt; 2^2^10
17976931348623159077293051907890247336179769789423065727343008115773267580550096
31327084773224075360211201138798713933576587897688144166224928474306394741243777
67893424865485276302219601246094119453082952085005768838150682342462881473913110
540827237163350510684586298239947245938479716304835356329624224137216
Prelude&gt; (2^2)^10
1048576</code></pre>
<p>…and also very large. By default, Haskell uses arbitrary precision integer arithmetic. Note that for this lecture, we will completely avoid and ignore floating point arithmetic.</p>
<p>In the last example we can see that Haskell interprets <code>a^b^c</code> as <code>a^(b^c)</code>, i.e. the power operator is <em>right associative</em>. It is worth noting that this information is not hard-coded in the compiler. Instead, when the operator is defined somewhere in a library, its associativity and precedence can be declared. We can ask the compiler about this information:</p>
<pre><code>Prelude&gt; :info (^)
(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a   -- Defined in ‘GHC.Real’
infixr 8 ^</code></pre>
<p>Let us ignore the first line (which is the type signature): The <code>r</code> in <code>infixr</code> tells us that the <code>(^)</code> operator is right-associative. And the number is the precedence; a higher number means that this operator binds more tightly.</p>
<div class="Exercise">
<p>What associativity do you expect for <code>(+)</code> and <code>(-)</code>? Verify your expectation.</p>
</div>
<div class="Solution">
<p>Both operator are left-associative, so that <code>10 - 2 + 3 - 4</code> means <code>((10 - 2) + 3) - 4</code> as expected.</p>
</div>
<div class="Exercise">
<p>Look up the precedences of the other arithmetic operations, and see how that corresponds to the PEMDAS rule.</p>
</div>
<div class="Solution">
<p>The precedences of <code>(+)</code> and <code>(-)</code> are the same, and smaller than the precedence of <code>(*)</code>, which is again shorter than the precedence of <code>(^)</code>.</p>
</div>
</section>
<section id="applying-functions" class="level2">
<h2><span class="header-section-number">1.2</span> Applying Functions</h2>
<p>So far we have a calculator (which is not useless, I sometimes use <code>ghci</code> as a calculator). But to get closer to functional programming, let us look at some functions that are already available to use.</p>
<p>To stay within the realm of arithmetic (if only to have something to talk about), let us play with the <code>div</code> and <code>mod</code> functions. These do what you would expect from them:</p>
<pre><code>Prelude&gt; div 123 100
1
Prelude&gt; mod 123 100
23</code></pre>
<p>We observe that to apply a function, we just write the function, followed by the arguments; no parenthesis or commas needed. This not only makes for more elegant and less noise code; but there is also a very deep and beautiful reason for this, which we will come to later.</p>
<p>At this point, surely someone wants to know what happens when we divide by 0:</p>
<pre><code>Prelude&gt; div 123 0
*** Exception: divide by zero</code></pre>
<p>Haskell has exceptions, they can even be caught etc., but let us talk about that later.</p>
<p>Of course, if the argument is not just a single number, we somehow have to make clear where the argument begins and ends:</p>
<pre><code>Prelude&gt; div (120 + 3) (10 ^ 2)
1</code></pre>
<p>(If you leave out the parenthesis, you get a horrible error messages). In technical terms, we can say that function application behaves like a left-associative operator of highest precedence. But it is easier to just remember <strong>function application binds most tightly</strong>. (Exception: Record construction and update binds even more tightly, although some consider that a design flaw.)</p>
<p>Just to have more examples, here are two other functions that we can play around with:</p>
<pre><code>Prelude&gt; id 42
42
Prelude&gt; const 23 42
23</code></pre>
<div class="Exercise">
<p>Can you predict the result of the following?</p>
<pre><code>Prelude&gt; 1 + const 2 3 + 4</code></pre>
</div>
<div class="Solution">
<pre><code>7</code></pre>
</div>
<p><strong>A note on syntactic sugar:</strong> Haskell is a high-calorie language: There is lots of syntactic sugar. Syntactic sugar refers to when there are alternative ways of writing something that <em>look</em> different, but <em>behave</em> the same. The goal is to allow the programmer to write the code in a way that best suits the reader, which is good, but it also means that a reader needs to know about the sugar.</p>
<p><strong>Infix operator application (syntactic sugar)</strong>: Functions that take two arguments can be written infix, as if they were an operator, by putting backticks around the name:</p>
<pre><code>Prelude&gt; 123 `div` 10
12
Prelude&gt; 123 `mod` 10
3
Prelude&gt; (120 + 3) `div` (10 ^ 2)
1
Prelude&gt; (120 + 3) `div` 10 ^ 2
1
Prelude&gt; ((120 + 3) `div` 10) ^ 2
144</code></pre>
<p>We see that written as operators, even functions have an associativity and precedence:</p>
<pre><code>Prelude&gt; :info div
class (Real a, Enum a) =&gt; Integral a where
  ...
  div :: a -&gt; a -&gt; a
  ...
    -- Defined in ‘GHC.Real’
infixl 7 `div`</code></pre>
<p><strong>Prefix operator application (syntactic sugar) ★</strong>: We can also go the other way, and use any operator as if it were a function, by wrapping it in parentheses:</p>
<pre><code>Prelude&gt; 1 + 1
2
Prelude&gt; (+) 1 1
2</code></pre>
<p><strong>The dollar operator (non-syntactic sugar) ★</strong>: Consider an expression that takes a number, and applies a number of functions , maybe with arguments, to it, such as:</p>
<pre><code>f5 (f4 (f3 (f2 (f1 42))))</code></pre>
<p>Passing a piece of data through a number of functions is very common, and some (including me) greatly dislike the accumulation of parentheses there. Therefore, it is idiomatic to use the <code>($)</code> operator:</p>
<pre><code>f5 $ f4 $ f3 $ f2 $ f1 42</code></pre>
<p>This operator takes a function as the first argument, an argument as the second argument, and applies the function to the argument. In that way, it is exactly the same as function application. But it is <em>right-associative</em> (instead of left-associative) and has the <em>lowest precedence</em> (instead of the highest precedence). An easier way of reading such code is to read <code>($)</code> as “the same as parenthesis around the rest of the line”.</p>
<p>I call this non-syntactic sugar, because the dollar operator it is not part of the built-in language, but can be define by anyone.</p>
<div class="Exercise">
<p>What is the result of</p>
<pre><code>Prelude&gt; (-) 5 $ div 16 $ (-) 10 $ 4 `div` 2</code></pre>
</div>
<div class="Solution">
<pre><code>3</code></pre>
</div>
</section>
<section id="booleans-and-branching" class="level2">
<h2><span class="header-section-number">1.3</span> Booleans and branching</h2>
<p>Some cryptographers might be happy to only write code that always does the same thing (yay, no side effects), but most of us pretty quickly want to write branching code.</p>
<p>As you would expect, Haskell has the usual operators to compare numbers:</p>
<pre><code>Prelude&gt; 1 + 1 == 2
True
Prelude&gt; 4 &lt; 5
True
Prelude&gt; 4 &gt;= 5
False
Prelude&gt; 23 /= 42
True</code></pre>
<p>We see that there are values <code>True</code> and <code>False</code>. We can combine them using the usual Boolean operators:</p>
<pre><code>Prelude&gt; 1 + 1 == 2 &amp;&amp; 5 &lt; 4
False
Prelude&gt; 1 + 1 == 2 || 5 &lt; 4
True</code></pre>
<p>And finally, we can use <code>if … then … else …</code> to branch based on such a Boolean expression:</p>
<pre><code>Prelude&gt; if 5 &lt; 0 then 0 else 1
1
Prelude&gt; if -5 &lt; 0 then 0 else 1
0</code></pre>
<p>The use of <code>if … then … else …</code> is actually not the most idiomatic way to code decisions in Haskell, and we will come back to that point later, but for now it is good enough.</p>
</section>
<section id="function-abstraction" class="level2">
<h2><span class="header-section-number">1.4</span> Function abstraction</h2>
<p>Assume you want to check a bunch of numbers as to whether they are multiples of 10 (so called “round numbers” in German). You can do that using <code>mod</code> and <code>(==)</code>:</p>
<pre><code>Prelude&gt; 5 `mod` 10 == 0
False
Prelude&gt; 10 `mod` 10 == 0
True
Prelude&gt; 11 `mod` 10 == 0
False
Prelude&gt; 20 `mod` 10 == 0
True
Prelude&gt; -20 `mod` 10 == 0
True
Prelude&gt; 123 `mod` 10 == 0
False</code></pre>
<p>But this gets repetitive quickly. And whenever we program something in a repetitive way, we try to recognize the <em>pattern</em> and abstract over the changing <em>parameter</em>, leaving only the common parts</p>
<p>Here, the common pattern is <code>x `mod` 10 == 0</code>, with a parameter named <code>x</code>. We can give this pattern a name, and use it instead:</p>
<pre><code>Prelude&gt; isRound x = x `mod` 10 == 0
Prelude&gt; isRound 5
False
Prelude&gt; isRound 10
True
Prelude&gt; isRound 11
False
Prelude&gt; isRound 20
True
Prelude&gt; isRound (-20)
True
Prelude&gt; isRound 123
False</code></pre>
<p>And now we are squarely in the realm of functional programming, as we have just defined out first function, <code>isRound</code>!</p>
<p>Note that we defined the <code>isRound</code> by way of an equation. And it really is an equation: Wherever we see <code>isRound something</code>, we can obtain its meaning by replacing it with <code>something `mod` 10 == 0</code>. This <em>equational reasoning</em>, where you replace equals by equals, is one key technique to make sense of Haskell programs.</p>
<div class="Exercise">
<p>Discuss: Think of other programming language that have concepts called functions. Can you always replace a function call with the function definition? Does it change the meaning of the program?</p>
</div>
<div class="Exercise">
<p>Write a function <code>absoluteValue</code> with one parameter. If the parameter is negative, returns its opposite number, otherwise the number itself.</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">absoluteValue x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="fu">-</span> x <span class="kw">else</span> x</a></code></pre></div>
</div>
<div class="Exercise">
<p>Write a function <code>isHalfRound</code> that checks if a number is divisible by 5, by checking whether the last digit is 0 or 5.</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1">isHalfRound x <span class="fu">=</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">5</span></a></code></pre></div>
</div>
<div class="Exercise">
<p>Write a function <code>isEven</code> that checks if a number is divisible by 2, by checking whether the last digit is 0, 2, 4, 6, 8.</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">isEven x <span class="fu">=</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">2</span> <span class="fu">||</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">4</span> <span class="fu">||</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">6</span> <span class="fu">||</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">8</span></a></code></pre></div>
</div>
<p>Of course, you can abstract over more than one parameter. In the last exercise, you had to write something like <code>x `div` 10 == y</code> a lot. So it makes sense to abstract over that:</p>
<pre><code>Prelude&gt; hasLastDigit x y = x `div` 10 == y</code></pre>
<p>This allows us to define <code>isHalfRound</code> as follows:</p>
<pre><code>Prelude&gt; isHalfRound x = x `hasLastDigit` 0 || x `hasLastDigit` 5</code></pre>
<p>which, if you read it out, is almost a transliteration of the specification! Here we see how abstraction, together with good naming and syntax, can produce very clear and readable code.</p>
<p><strong>Infix operator application again (syntactic sugar)</strong>: By the way, you can use infix operator syntax already when defining a function:</p>
<pre><code>x `divides` y = x `div` y == 0</code></pre>
</section>
<section id="recursion" class="level2">
<h2><span class="header-section-number">1.5</span> Recursion</h2>
<p>We already saw that one function that we defined could call another. But the real power of general computation comes when a function can call itself, i.e. when we employ recursion. Recursion is a very fundamental technique in functional programming, much more so than loops or iterators or such.</p>
<p>Let us come up with a function that determines the number of digits in a given number. We first check if the number is already just one digit:</p>
<pre><code>Prelude&gt; countDigits n = if n &lt; 10 then 1 else █</code></pre>
<p>At this point, we know that the number is larger than 10. So to count the digits, we would like to cut off one digit:</p>
<pre><code>Prelude&gt; countDigits n = if n &lt; 10 then 1 else (n `div` 10)█</code></pre>
<p>and count the number of digits of <em>that</em> number</p>
<pre><code>Prelude&gt; countDigits n = if n &lt; 10 then 1 else countDigits (n `div` 10)█</code></pre>
<p>and, of course, add one to that number:</p>
<pre><code>Prelude&gt; countDigits n = if n &lt; 10 then 1 else countDigits (n `div` 10) + 1
Prelude&gt; countDigits 0
1
Prelude&gt; countDigits 5
1
Prelude&gt; countDigits 10
2
Prelude&gt; countDigits 11
2
Prelude&gt; countDigits 99
2
Prelude&gt; countDigits 100
3
Prelude&gt; countDigits 1000
4
Prelude&gt; countDigits (10^12345)
12346</code></pre>
<p>The fact that we can replace equals with equals does not change just because we use recursion. For example, we can figure out what <code>countDigits 789</code> does by replacing equals with equals:</p>
<pre><code>  countDigits 789
= if 789 &lt; 10 then 1 else countDigits (789 `div` 10) + 1
= if False then 1 else countDigits (789 `div` 10) + 1
= countDigits (789 `div` 10) + 1
= countDigits 78 + 1
= (if 78 &lt; 10 then 1 else countDigits (78 `div` 10) + 1) + 1
= (if False then 1 else countDigits (78 `div` 10) + 1) + 1
= (countDigits (78 `div` 10) + 1) + 1
= (countDigits 7 + 1) + 1
= ((if 7 &lt; 10 then 1 else countDigits (7 `div` 10) + 1) + 1) + 1
= ((if True then 1 else countDigits (7 `div` 10) + 1) + 1) + 1
= (1 + 1) + 1
= 2 + 1
= 3</code></pre>
<div class="Exercise">
<p>Write the function <code>sumDigits</code> that sums up the digits of a natural number.</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1">sumDigits n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="kw">then</span> n <span class="kw">else</span> sumDigits (n <span class="ot">`div`</span> <span class="dv">10</span>) <span class="fu">+</span> (n <span class="ot">`mod`</span> <span class="dv">10</span>)</a></code></pre></div>
</div>
</section>
<section id="higher-order-functions" class="level2">
<h2><span class="header-section-number">1.6</span> Higher-order functions</h2>
<p>We created functions when we took expressions that followed a certain pattern, and abstracted over a number that occurred therein. But the thing we can abstract over does not have to be just a simple number. It could also be a function!</p>
<p>Consider the task of calculating the number of digits in the number of digits of a number:</p>
<pre><code>Prelude&gt; countDigits (countDigits 5)
1
Prelude&gt; countDigits (countDigits 10)
1
Prelude&gt; countDigits (countDigits (10^10))
2
Prelude&gt; countDigits (countDigits (10^123))
3
Prelude&gt; countDigits (countDigits (15^15))
2</code></pre>
<p>Clearly, we can abstract over the argument here:</p>
<pre><code>Prelude&gt; countCountDigits n = countDigits (countDigits n)
Prelude&gt; countCountDigits (10^123)
3</code></pre>
<p>But now consider we also want <code>sumSumDigits</code>:</p>
<pre><code>Prelude&gt; sumSumDigits n = sumDigits (sumDigits n)
Prelude&gt; sumSumDigits (9^9)
9
Prelude&gt; sumSumDigits (7^7)
7
Prelude&gt; sumSumDigits (13^13)
13
Prelude&gt; sumSumDigits (15^15)
18</code></pre>
<p>There is clearly a pattern that is shared by both <code>countCountDigits</code> and <code>sumSumDigits</code>: They both apply a function twice. And indeed, we can abstract over that pattern:</p>
<pre><code>Prelude&gt; twice f x = f (f x)
Prelude&gt; twice countDigits (15^15)
2
Prelude&gt; twice sumDigits (15^15)
18</code></pre>
<p>This is our first <em>higher order function</em>, and it is called so because it is a function that take another function as an argument. More precisely, it is called a second-order function, because it takes a normal, i.e. first-order function, as an argument. Abstracting over a second order function yields a third order function, and so on. Up to <a href="https://doi.org/10.1017/S0956796898003001">sixth-order functions</a> are seen in the wild.</p>
<p>If you look at the last two lines, we again see a common pattern. And abstracting over that, we recover very nice and declarative definitions for <code>countCountDigits</code> and <code>sumSumDigits</code>:</p>
<pre><code>Prelude&gt; countCountDigits x = twice countDigits x
Prelude&gt; sumSumDigits x = twice sumDigits x</code></pre>
<p>The ability to abstract very easily over functions is an important ingredient in making Haskell so excellent at abstraction: It allows to abstract over <em>behavior</em>, instead merely over <em>value</em>. To demonstrate that, let us recall the definitions of <code>countDigits</code> and <code>someDigits</code>:</p>
<pre><code>Prelude&gt; countDigits n = if n &lt; 10 then 1 else countDigits (n `div` 10) + 1
Prelude&gt; sumDigits n = if n &lt; 10 then n else sumDigits (n `div` 10) + (n `mod` 10)</code></pre>
<p>These two functions share something: They share a behavior! Both iterate over the digits of the function, do something at each digit, and sum something up. And this common functionality is not trivial! So it is very unsatisfying to copy’n’paste it, like we did. So how can we abstract over the parts that differ? It is not obvious on first glance, so go through it step by step, lets give the parts that differ names. For <code>countDigits</code>, we <em>ignore</em> the digit, and just sum up ones:</p>
<pre><code>Prelude&gt; always1 n = 1
Prelude&gt; countDigits n = if n &lt; 10 then always1 n else countDigits (n `div` 10) + always1 (n `mod` 10)</code></pre>
<p>And for <code>sumDigits</code>, we use the digit as is. And we have already seen a function that just returns its argument, the identity function:</p>
<pre><code>Prelude&gt; sumDigits n = if n &lt; 10 then id n else sumDigits (n `div` 10) + id (n `mod` 10)</code></pre>
<p>Now the common pattern is clear, and we can abstract over the different parts:</p>
<pre><code>Prelude&gt; sumDigitsWith f n = if n &lt; 10 then f n else sumDigitsWith f (n `div` 10) + f (n `mod` 10)
Prelude&gt; countDigits n = sumDigitsWith always1 n
Prelude&gt; sumDigits n = sumDigitsWith id n</code></pre>
<p>To recapitulate: We took two functions that were doing somehow related things, and we rewrote them to clearly separate the common parts from the differing parts, and then we could extract the shared essence into its own, higher-order function.</p>
<p>This single mechanism – abstracting over functions – can <a href="https://www.voxxed.com/2016/04/gang-four-patterns-functional-light-part-1/">replace thick volumes full of design patterns</a> in non-functional programming paradigms.</p>
<p>Note that if one would have to abstract <code>countDigits</code> and <code>sumDigits</code> to <code>sumDigitsWith</code> in practice, one would probably not rewrite them first with <code>id</code> etc., but just look at them and come up with <code>sumDigitsWith</code> directly.</p>
<div class="Exercise">
<p>Write a (recursive) function <code>fixEq</code> so that <code>fixEq f x</code> repeatedly applies <code>f</code> to <code>x</code> until the result does not change.</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1">fixEq f x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> f x <span class="kw">then</span> x <span class="kw">else</span> fixEq f (f x)</a></code></pre></div>
</div>
<div class="Exercise">
<p>Use this function and <code>countDigits</code> to write a function <code>isMultipleOf3</code> so that <code>isMultipleOf3 x</code> is true if repeatedly applying <code>countDigits</code> to <code>x</code> results in 3 or 9.</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1">isMultipleOf3 x <span class="fu">=</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">3</span> <span class="fu">||</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">6</span> <span class="fu">||</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">9</span></a></code></pre></div>
</div>
</section>
<section id="anonymous-functions" class="level2">
<h2><span class="header-section-number">1.7</span> Anonymous functions</h2>
<p>We defined a function <code>always1</code>, but it seems a bit silly to give a name to such a specialized and small concept. Therefore, Haskell allows us to define <em>anonymous functions</em> on the fly. The syntax is a backslash, followed by the parameter (or parameters), followed by the body of the function. So we can define <code>countDigits</code> and <code>sumDigits</code> without any helper functions like this:</p>
<pre><code>Prelude&gt; countDigits n = sumDigitsWith (\d -&gt; 1) n
Prelude&gt; sumDigits n = sumDigitsWith (\d -&gt; d) n</code></pre>
<p>These are also called <em>lambda abstractions</em>, because they are derived from the Lambda calculus, and the backslash is a poor imitation of the Greek letter lambda (λ).</p>
</section>
<section id="higher-order-function-definition" class="level2">
<h2><span class="header-section-number">1.8</span> Higher-order function definition</h2>
<p>Lets look at the previous two definitions, and remember that when we define a function this way, we define what to replace the left-hand side with. But notice that the argument <code>n</code> is not touched at all by this definition! So we should get the same result if we simply omit it from the equation, right? And indeed, we can just as well write</p>
<pre><code>Prelude&gt; countDigits = sumDigitsWith (\d -&gt; 1)
Prelude&gt; sumDigits = sumDigitsWith (\d -&gt; d)</code></pre>
<p>It looks as if we just saved two characters. But what really just happened is that we shifted our perspective, and raised the level of abstraction by one layer. Instead of defining a <code>countDigits</code> as a function that takes a number and produces another number, we have defined <code>countDigits</code> as the result of instantiating the pattern <code>sumDigitsWith</code> with the function <code>(\d -&gt; 1)</code>. At this level of thought, we do not care about the argument to <code>countDigits</code>, i.e. what it is called or so.</p>
<div class="Exercise">
<p>Which other recent definitions can be changed accordingly?</p>
</div>
<div class="Solution">
<p>The definitions for <code>countCountDigits</code> and <code>sumSumDigits</code>:</p>
<pre><code>Prelude&gt; countCountDigits = twice countCountDigits
Prelude&gt; sumSumDigits = twice sumDigits</code></pre>
</div>
</section>
<section id="currying" class="level2">
<h2><span class="header-section-number">1.9</span> Currying</h2>
<p>We have already seen functions that <em>receive</em> a function as an argument. The way we use <code>twice</code> or <code>sumDigitsWith</code> here, we can think of them as a function that <em>return</em> functions. And this brings us to the deep and beautiful explanation we write multiple arguments to functions the way we do: Because really, every function only ever has one argument, and returns another one.</p>
<p>We can <em>think</em> of <code>twice</code> has having two arguments (the function <code>f</code>, and the value <code>x</code>), but really, <code>twice</code> is a function that takes one argument (the function <code>f</code>), and returns another function, that then takes the value <code>x</code>. This “other” function is what we named in the above definition of <code>sumSumDigits</code>.</p>
</section>
<section id="the-composition-operator" class="level2">
<h2><span class="header-section-number">1.10</span> The composition operator ★</h2>
<p>Because writing code that passes functions around and modifies them (like in <code>twice</code> or <code>sumDigitsWith</code>) is so important in this style of programming, I should at this point introduce the composition operator. It is already pre-defined, but we can define it ourselves:</p>
<pre><code>Prelude&gt; (f . g) x = f (g x)</code></pre>
<p>The dot is a poor approximation of the mathematical symbol for function composition, “∘”, and can be read as “<code>f</code> after <code>g</code>”. Note <code>x</code> is passed to <code>g</code> first, and then the result to <code>f</code>.</p>
<p>It looks like a pretty vacuous definition, but it is very useful in writing high-level code. For example, it allows us the following, nicely abstract definition of <code>twice</code>:</p>
<pre><code>Prelude&gt; twice f = f . f</code></pre>
<p>Do you remember the example we used when introducing the dollar operator? We started with</p>
<pre><code>f5 (f4 (f3 (f2 (f1 42))))</code></pre>
<p>and rewrote it to</p>
<pre><code>f5 $ f4 $ f3 $ f2 $ f1 42</code></pre>
<p>Now imagine we want to abstract over 42:</p>
<pre><code>many_fs x = f5 (f4 (f3 (f2 (f1 x))))</code></pre>
<p>This function really is just the composition of a bunch of function. So an idiomatic way of writing it would be</p>
<pre><code>many_fs  = f5 . f4 . f3 . f2 . f1</code></pre>
<p>where again, the actual value is no longer the emphasis, but rather the functions.</p>
<p>The value <code>x</code> is sometimes called the point (as in geometry), and this style of programming is called <em>points-free</em> (or sometimes <em>pointless</em>).</p>
</section>
<section id="laziness" class="level2">
<h2><span class="header-section-number">1.11</span> Laziness ★</h2>
<p>As a final bit in this section, let’s talk about laziness. Most often this can be ignored when reading Haskell code, and in general laziness is not as important (or as bad) as some people say it is. But it plays an important role in Haskell’s support for abstraction, so let’s briefly look at it.</p>
<p>Laziness means that an expression is evaluated as late as possible, i.e. when it is needed to make a branching decision, or when it is to be printed on the screen. We can only observe when things are being evaluated when we have side-effects, and the only side effects we can produce so far are non-termination and exceptions. So let us use division by zero to observe that the first argument to <code>const</code> is used, but the second one is not:</p>
<pre><code>Prelude&gt; 0 `div` 0
*** Exception: divide by zero
Prelude&gt; const (0 `div` 0) 1
*** Exception: divide by zero
Prelude&gt; const 1 (0 `div` 0)
1</code></pre>
<p>To see why this is so crucial for abstraction, consider the following two functions that implement a safe version of <code>div</code> and <code>mod</code> that just returns 0 if the user tries to divide by 0:</p>
<pre><code>Prelude&gt; x `safeDiv` y = if y == 0 then 0 else x `div` y
Prelude&gt; x `safeMod` y = if y == 0 then 0 else x `mod` y
Prelude&gt; 10 `safeDiv` 5
2
Prelude&gt; 10 `safeDiv` 0
0</code></pre>
<p>Clearly, the definitions of <code>safeDiv</code> and <code>safeMod</code> share a pattern. So let us extract the pattern “if y is zero then return zero else do something else”:</p>
<pre><code>Prelude&gt; unlessZero y z = if y == 0 then 0 else z
Prelude&gt; x `safeDiv` y = unlessZero y (x `div` y)
Prelude&gt; x `safeMod` y = unlessZero y (x `mod` y)
Prelude&gt; 10 `safeDiv` 5
2
Prelude&gt; 10 `safeDiv` 0
0</code></pre>
<p>So that works. But it only works because Haskell is lazy. Consider what would happen in a strict language, where expressions are evaluated before passed to a function:</p>
<pre><code>  10 `safeDiv` 0
= unlessZero 0 (10 `div` 0)
= unlessZero 0 (*** Exception: divide by zero</code></pre>
<p>Only with laziness can we easily abstract not only over computations, but even over control flow, and create our own control flow constructs – simply as higher-order functions!</p>
<p>In fact, even <code>if … then … else</code> could just be a normal function with three parameters, defined somewhere in the standard library. The fact that there is special syntax for it is pure convenience – which, again, is not the case in strict languages.</p>
</section>
</section>
<section id="types" class="level1">
<h1><span class="header-section-number">2</span> Types</h1>
<p>In the first section, we have seen how functional programming opens the way to abstraction, and to condense independent concerns into separate pieces of code. This is a very powerful tool for modularity, and to focus on the relevant part of a problem, while keeping the bookkeeping out of sight. But powerful is also dangerous – using a higher order function correctly without any aid, can be mind-bending.</p>
<p>Whenever we write functions like in the previous section, we have an idea in our head about what their arguments are – are they just numbers, or are they functions, and what kind of functions – and what they return. It is obvious to us that writing <code>twice isEven</code> does not make sense, because <code>isEven</code> returns <code>True</code> or <code>False</code>, but expects a number, so it cannot be applied to itself.</p>
<p>This is all simple and obvious, but it is a lot to keep in your head as the code grows larger, and even more so once the code is changing and there are more people working on it. So to keep this power and complexity manageable, Haskell has a strong static type system, which is essentially a way for you to communicate with the compiler about these ideas you have in your head. You can ask the compiler “what do you know about this function? what can it take, what kind of things does it return?”. And you can tell the compiler “this function ought to take this and return that (and please tell me if you disagree)”.</p>
<p>In fact, many Haskellers prefer to do type-driven development: First think about and write down the type of the function they need to create, and <em>then</em> think about implementing them.</p>
<p>Besides communicating with the compiler, types are also crucial in communicating with your fellow developers and/or users of your API. For many functions, the type alone, or the type and the name, is sufficient to tell you what it does.</p>
<section id="tooling-interlude-editing-files" class="level2">
<h2><span class="header-section-number">2.1</span> Tooling interlude: Editing files ★</h2>
<p>At this point, we should switch from working exclusively in the REPL to writing an actual Haskell file. We can start by creating a file <code>Types.hs</code>, and put in the code from the previous section:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" title="1">isRound x <span class="fu">=</span> x <span class="ot">`mod`</span> <span class="dv">10</span> <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb59-2" title="2">hasLastDigit x y <span class="fu">=</span> x <span class="ot">`div`</span> <span class="dv">10</span> <span class="fu">==</span> y</a>
<a class="sourceLine" id="cb59-3" title="3">isHalfRound x <span class="fu">=</span> x <span class="ot">`hasLastDigit`</span> <span class="dv">0</span> <span class="fu">||</span> x <span class="ot">`hasLastDigit`</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb59-4" title="4">x <span class="ot">`divides`</span> y <span class="fu">=</span> x <span class="ot">`div`</span> y <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb59-5" title="5">twice f x <span class="fu">=</span> f (f x)</a>
<a class="sourceLine" id="cb59-6" title="6">countCountDigits x <span class="fu">=</span> twice countDigits x</a>
<a class="sourceLine" id="cb59-7" title="7">sumSumDigits x <span class="fu">=</span> twice sumDigits x</a>
<a class="sourceLine" id="cb59-8" title="8">sumDigitsWith f n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="kw">then</span> f n <span class="kw">else</span> sumDigitsWith f (n <span class="ot">`div`</span> <span class="dv">10</span>) <span class="fu">+</span> f (n <span class="ot">`mod`</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb59-9" title="9">countDigits <span class="fu">=</span> sumDigitsWith (\d <span class="ot">-&gt;</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb59-10" title="10">sumDigits <span class="fu">=</span> sumDigitsWith (\d <span class="ot">-&gt;</span> d)</a>
<a class="sourceLine" id="cb59-11" title="11">fixEq f x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> f x <span class="kw">then</span> x <span class="kw">else</span> fixEq f (f x)</a>
<a class="sourceLine" id="cb59-12" title="12">isMultipleOf3 x <span class="fu">=</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">3</span> <span class="fu">||</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">6</span> <span class="fu">||</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">9</span></a></code></pre></div>
<p>We can load this file into <code>ghci</code> by either starting it with <code>ghci Types.hs</code> or by typing <code>:load Types.hs</code>. After you change and save the file, you can reload with <code>:reload</code> (or simply <code>:r</code>)</p>
</section>
<section id="basic-types" class="level2">
<h2><span class="header-section-number">2.2</span> Basic types</h2>
<p>As I mentioned before, you can chat with the compiler about the types of things, and ask what it thinks they are. We can do that with the <code>:type</code> (or <code>:t</code>) command:</p>
<pre><code>*Main&gt; :t sumDigits
sumDigits :: Integer -&gt; Integer</code></pre>
<p>Here, GHC tells us the type of <code>sumDigits</code>, in the form of a <em>type annotation</em>, i.e. a term (<code>sumDigits</code>) followed by two colons, followed by its type. The type itself tells us that <code>sumDigits</code> is a function (as indicated by the arrow) that takes an <code>Integer</code> as an argument and returns an <code>Integer</code> as a result. Which greatly matches our expectation!</p>
<p>Instead of asking GHC for the type, we can also specify it, simply by adding the line</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" title="1"><span class="ot">sumDigits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a></code></pre></div>
<p>to the file (commonly directly above the function definition, rarely all bundled up in the beginning).</p>
<p>If we insert a type annotation that does not match what we wrote in the code, for example, if we added</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" title="1"><span class="ot">isRound ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a></code></pre></div>
<p>we would get an error message like</p>
<pre><code>types.hs:2:13: error:
    • Couldn&#39;t match expected type ‘Integer’ with actual type ‘Bool’
    • In the expression: x `mod` 10 == 0
      In an equation for ‘isRound’: isRound x = x `mod` 10 == 0
  |
2 | isRound x = x `mod` 10 == 0
  |             ^^^^^^^^^^^^^^^</code></pre>
<p>Note that the compiler believes the type signature, and complains about the code, not the other way around.</p>
<p>The error message mentions a type <code>Bool</code> which, as you can guess, is the type of Boolean expressions, e.g. <code>True</code> and <code>False</code>. With this knowledge, we can write the correct type signature for <code>isRound</code>:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" title="1"><span class="ot">isRound ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
</section>
<section id="polymorphism" class="level2">
<h2><span class="header-section-number">2.3</span> Polymorphism</h2>
<p>Let us consider <code>twice</code> for a moment, and think about what to expect from its type. It is a function that takes two arguments, and the first argument ought to be a function itself… and here is how GHC writes this:</p>
<pre><code>*Main&gt; :t twice
twice :: (t -&gt; t) -&gt; t -&gt; t</code></pre>
<p>From this example, we learn that * the type of functions with multiple arguments is written using multiple arrows, * the function arrow can just as occur inside an argument, namely when an argument itself is a function.</p>
<p>But what is this type <code>t</code>? There is not, actually, a type called <code>t</code>. Instead, this is a <em>type variable</em>, meaning that the function <code>twice</code> can be used with any type. Any lower-case identifier in a type is a type variable (not just <code>t</code>), and concrete types are always upper-case.</p>
<p>Here we can see that we can use <code>twice</code> with numbers, Booleans, and even with functions:</p>
<pre><code>*Main&gt; twice countDigits (99^99)
3
*Main&gt; twice not True
True
*Main&gt; twice twice countDigits (99^99)
1</code></pre>
<p>What does not work is passing a function to <code>twice</code> that works on numbers, but then pass a <code>Bool</code>:</p>
<pre><code>*Main&gt; twice countDigits True

&lt;interactive&gt;:12:19: error:
    • Couldn&#39;t match expected type ‘Integer’ with actual type ‘Bool’
    • In the second argument of ‘twice’, namely ‘True’
      In the expression: twice countDigits True
      In an equation for ‘it’: it = twice countDigits True</code></pre>
<p>In other words: The <code>t</code>s in the type of <code>twice</code> can become <em>any</em> type, but it has the be the same type everywhere.</p>
<div class="Exercise">
<p>What do you think is the type of <code>id</code>?</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" title="1"><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
</div>
<p>If we ask for the type of the function <code>const</code>, we see two different type variables:</p>
<pre><code>*Main&gt; :t const
const :: a -&gt; b -&gt; a</code></pre>
<p>And here we can indeed instantiate them at different types:</p>
<pre><code>*Main&gt; :t const True 1
const True 1 :: Bool</code></pre>
</section>
<section id="constrained-types-a-first-glimpse" class="level2">
<h2><span class="header-section-number">2.4</span> Constrained types (a first glimpse)</h2>
<p>There are more polymorphic functions in our initial set, for example <code>fixEq</code>:</p>
<pre><code>*Main&gt; :t fixEq
fixEq :: Eq t =&gt; (t -&gt; t) -&gt; t -&gt; t</code></pre>
<p>The part after the <code>=&gt;</code> is what we expect: two arguments, the first a function, all the same types, just like with <code>twice</code>. The part before the <code>=&gt;</code> is new: It is a <em>constraint</em>, and it limits which types <code>t</code> can be instantiated with. Remember that <code>fixEq</code> uses <code>(==)</code> to check if the value has stabilized. But not all values can be compared for equality! (In particular, functions cannot). So <code>fixEq</code> does not work with any type, but only those that support equality. This is what <code>Eq t</code> indicates, and indeed we get an error message when we try to do it wrongly:</p>
<pre><code>*Main&gt; fixEq twice not True

&lt;interactive&gt;:27:1: error:
    • No instance for (Eq (Bool -&gt; Bool)) arising from a use of ‘fixEq’
        (maybe you haven&#39;t applied a function to enough arguments?)
    • In the expression: fixEq twice not True
      In an equation for ‘it’: it = fixEq twice not True</code></pre>
<p>This <code>Eq</code> thing is not some built-in magic, but rather a <em>type class</em>, another very powerful and important feature of Haskell, which we will dive into separately later.</p>
<p>Other functions in our list are polymorphic where we may not have expected it:</p>
<pre><code>*Main&gt; :t sumDigitsWith
sumDigitsWith :: (Integral a1, Num a2) =&gt; (a1 -&gt; a2) -&gt; a1 -&gt; a2</code></pre>
<p>This is not the type we might have expected! This is because Haskell supports different numeric types, and uses type classes to overload the numeric operations. But remember that typing is a conversation: We can simply tell GHC that we want a different (more specific) type for <code>sumDigitsWith</code>, by adding</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb74-1" title="1"><span class="ot">sumDigitsWith ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a></code></pre></div>
<p>to our file. In fact, in practice one <em>always</em> writes full type signatures for all top-level definitions, so this should be less of a problem for Haskell readers.</p>
</section>
<section id="parametricity" class="level2">
<h2><span class="header-section-number">2.5</span> Parametricity</h2>
<p>One obvious use for such polymorphism is to write code once, and use it at different types. But there is another great advantage of polymorphic functions, even if we only ever intend to instantiate the type variables with the same type, and that is reasoning by parametricity.</p>
<p>In a function with a polymorphic type like <code>twice</code> there is not a lot we can do with the parameters. Sure, we can apply <code>f</code> to <code>x</code>, and maybe apply <code>f</code> more than once. But that is just about all we can do: Because <code>x</code> can have an arbitrary type, we cannot do arithmetic with it, we cannot print it, we cannot even compare it to other values of type <code>x</code>.</p>
<p>This severely restricts what <code>twice</code> can do at all … but on the other hand means that just from looking at the type signature of <code>twice</code> we already know a lot about what it does.</p>
<p>A very simple example for that is the function <code>id</code>, with type <code>a -&gt; a</code>. <em>Any</em> function of this type will either</p>
<ul>
<li>return its argument (i.e. be the identity function),</li>
<li>return never (i.e. go into an infinite loop), or</li>
<li>raise an exception.</li>
</ul>
<div class="Exercise">
<p>A great example for the power of polymorphism is the following type signature:</p>
<pre><code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code></pre>
<p>There is a function of that type in the standard library. Can you tell what it does? Can you guess its name? You can use a type-based search engine like <a href="https://www.haskell.org/hoogle/?hoogle=%28a+-%3E+b+-%3E+c%29+-%3E+b+-%3E+a+-%3E+c">Hoogle</a> to find the function.</p>
</div>
<div class="Solution">
<p>It is the function <code>flip</code> that takes a function and swaps its first two arguments.</p>
</div>
</section>
<section id="algebraic-data-types" class="level2">
<h2><span class="header-section-number">2.6</span> Algebraic data types</h2>
<p>The function type is very expressive, and one can model many data structures purely with functions. But of course it is more convenient to use dedicated data structures. There are a number of data structure types that come with the standard library, in particular tuples, lists, the <code>Maybe</code> type. But it is more instructive to first look at how we can define our own.</p>
<p>We can declare new data types using the <code>data</code> keyword, the name of the type, the <code>=</code> sign, and then a list of <em>constructors</em>, separated by pipes (<code>|</code>). The form of these declarations is a bit odd, e.g. it uses <code>=</code> although it is not really an equality, but let us look at it step by step.</p>
<section id="enumerations" class="level3">
<h3><span class="header-section-number">2.6.1</span> Enumerations</h3>
<p>In the simplest case, we can use this to declare an enumeration type:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb76-1" title="1"><span class="kw">data</span> <span class="dt">Suit</span> <span class="fu">=</span> <span class="dt">Diamonds</span> <span class="fu">|</span> <span class="dt">Clubs</span> <span class="fu">|</span> <span class="dt">Hearts</span> <span class="fu">|</span> <span class="dt">Spades</span></a></code></pre></div>
<p>From now on, we can use the constructors, e.g. <code>Diamonds</code> as values of type <code>Suit</code>. This is how we <em>create</em> values of type <code>Suit</code> – and it is the only way, so we know that every value of type <code>Suit</code> is, indeed, one of these four constructors.</p>
<p>Note that <code>Suit</code> is a <em>type</em>, i.e. something you can use in type signatures, while <code>Diamonds</code> and the other constructors are <em>values</em>, i.e. something you can use in your function definitions.</p>
<p>When we have a value of type <code>Suit</code> then the only thing we can really do with it is to find out which of these four constructors it actually is. The way to do that is using <em>pattern matching</em>, for example using the <code>case … of …</code> syntax:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb77-1" title="1"><span class="ot">isRed ::</span> <span class="dt">Suit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb77-2" title="2">isRed s <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb77-3" title="3">  <span class="dt">Diamonds</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb77-4" title="4">  <span class="dt">Hearts</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb77-5" title="5">  _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>The expression <code>case e of …</code> evaluates the <em>scrutinee</em> <code>e</code>, and then sequentially goes through the list of cases. If the value of the scrutinee matches the <em>pattern</em> left of the arrow, the whole expression evaluates to the right-hand side. We see two kinds of patterns here: Constructor patterns like <code>Diamonds</code>, which match simply when the value is, indeed, the constructor, and the <em>wildcard pattern</em>, written as an underscore, which matches any value.</p>
<p>It is common to immediately pattern match on the parameter of a function, so Haskell supports pattern-matching directly in the function definition:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb78-1" title="1"><span class="ot">isRed ::</span> <span class="dt">Suit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb78-2" title="2">isRed <span class="dt">Diamonds</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb78-3" title="3">isRed <span class="dt">Hearts</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb78-4" title="4">isRed _ <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>The type <code>Bool</code> that we have already used before is merely one of these enumeration types, defined as</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb79-1" title="1"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span></a></code></pre></div>
<p>and we could do without <code>if … then … else …</code> by pattern-matching on <code>Bool</code>:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb80-1" title="1"><span class="ot">ifThenElse ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb80-2" title="2">ifThenElse <span class="dt">True</span> x y <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb80-3" title="3">ifThenElse <span class="dt">False</span> x y <span class="fu">=</span> y</a></code></pre></div>
<p>The only reason to have <code>if … then … else …</code> is that it is a bit more readable.</p>
</section>
<section id="constructor-with-parameters" class="level3">
<h3><span class="header-section-number">2.6.2</span> Constructor with parameters</h3>
<p>So far, the constructors were just plain values. But we can also turn them into “containers” of sort, where we can store other values. As an basic example, maybe we want to introduce complex numbers:</p>
<pre><code>data Complex = C Integer Integer</code></pre>
<p>(Mathematically educated readers please excuse the use of <code>Integers</code> here.)</p>
<p>This creates a new type <code>Complex</code>, with a constructor <code>C</code>. But <code>C</code> itself is not a value of type <code>Complex</code>, but rather it is a function that creates values of type <code>Complex</code> and, crucially, it is the only way of creating values of type <code>Complex</code>. We can ask for the type of <code>C</code> and see that it is indeed just a function:</p>
<pre><code>Prelude&gt; :t C
C :: Integer -&gt; Integer -&gt; Complex</code></pre>
<p>so it should be clear how to use it:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb83-1" title="1"><span class="ot">origin ::</span> <span class="dt">Complex</span></a>
<a class="sourceLine" id="cb83-2" title="2">origin <span class="fu">=</span> <span class="dt">C</span> <span class="dv">0</span> <span class="dv">0</span></a></code></pre></div>
<p>Note that in the above declaration, <code>Complex</code> is a type, <code>C</code> is a term, but <code>Integer</code> is again a type.</p>
<p>Again the way to use a complex number is by pattern matching. This time we use pattern matching not to distinguish different cases – <em>every</em> <code>Complex</code> is a <code>C</code> – but to extract the parameters of the constructor:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb84-1" title="1"><span class="ot">addC ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span></a>
<a class="sourceLine" id="cb84-2" title="2">addC (<span class="dt">C</span> x1 y1) (<span class="dt">C</span> x2 y2) <span class="fu">=</span> <span class="dt">C</span> (x1 <span class="fu">+</span> x2) (y1 <span class="fu">+</span> y2)</a></code></pre></div>
<p>The parameter in a pattern – the <code>x1</code> here – can itself be a pattern, for example <code>0</code> (which matches only the number 0), or underscore:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb85-1" title="1"><span class="ot">isReal ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb85-2" title="2">isReal (<span class="dt">C</span> <span class="dv">0</span> _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb85-3" title="3">isReal _ <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>A type like <code>Complex</code>, with exactly one constructor, is called a <em>product type</em>. But we can of course have types with more than one constructor and constructor arguments:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb86-1" title="1"><span class="kw">data</span> <span class="dt">Riemann</span> <span class="fu">=</span> <span class="dt">Complex</span> <span class="dt">Complex</span> <span class="fu">|</span> <span class="dt">Infinity</span></a></code></pre></div>
<p>This declares a new type <code>Riemann</code> that can be built using one of these two constructors:</p>
<ol type="1">
<li><p>The constructor <code>Complex</code>, which takes one argument, of type <code>Complex</code>. Types and terms (including constructors) have different namespaces, so we can have a type called <code>Complex</code>, and a constructor called <code>Complex</code>, and they can be completely unrelated. This can be confusing, but is rather idiomatic.</p>
<p>The type of <code>Complex</code> shows that we can use it as a function, to create a point of the <code>Riemann</code> sphere from a complex number:</p>
<pre><code>Prelude&gt; :t Complex
Complex :: Complex -&gt; Riemann</code></pre></li>
<li><p>The constructor <code>Infinity</code> takes no arguments, and simply is a value of type <code>Riemann</code> itself.</p></li>
</ol>
<p>When we pattern match on a value of type <code>Riemann</code>, we learn whether it was created using <code>Complex</code> or <code>Infinity</code>, and in the former case, we also get the complex number passed to it:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb88-1" title="1"><span class="ot">addR ::</span> <span class="dt">Riemann</span> <span class="ot">-&gt;</span> <span class="dt">Riemann</span> <span class="ot">-&gt;</span> <span class="dt">Riemann</span></a>
<a class="sourceLine" id="cb88-2" title="2">addR (<span class="dt">Complex</span> c1) (<span class="dt">Complex</span> c2) <span class="fu">=</span> <span class="dt">Complex</span> (c1 <span class="ot">`add`</span> c2)</a>
<a class="sourceLine" id="cb88-3" title="3">addR <span class="dt">Infinity</span> _  <span class="fu">=</span> <span class="dt">Infinity</span></a>
<a class="sourceLine" id="cb88-4" title="4">addR _ <span class="dt">Infinity</span>  <span class="fu">=</span> <span class="dt">Infinity</span></a></code></pre></div>
<p>A data type that has more than one constructor is commonly called a <em>sum type</em>. Because <code>data</code> allows you to build types from sums and products, they are called algebraic data types (ADTs).</p>
</section>
<section id="recursive-data-types" class="level3">
<h3><span class="header-section-number">2.6.3</span> Recursive data types</h3>
<p>It it worth pointing out that it is completely fine to haven a constructor argument of the type that we are currently defining. This way, we obtain a <em>recursive data type</em>, and this is the foundation for many important data structures, in particular lists and trees of various sorts. Here is a simple example, a binary tree with numbers on all internal nodes:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb89-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Integer</span> <span class="dt">Tree</span> <span class="dt">Tree</span></a></code></pre></div>
<p>Again, this can be read as “a value of type <code>Tree</code> is either a <code>Leaf</code>, or it is a <code>Node</code> that contains a value of type <code>Integer</code> and references to two subtrees.”</p>
<p>There is nothing particularly interesting about constructing such a tree (use <code>Leaf</code> and <code>Node</code>) and traversing it (use pattern matching). Here is a piece of idiomatic code that inserts a new number into a tree:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb90-1" title="1"><span class="ot">insert ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb90-2" title="2">insert x <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb90-3" title="3">insert x (<span class="dt">Node</span> y t1 t2)</a>
<a class="sourceLine" id="cb90-4" title="4">    <span class="fu">|</span> y <span class="fu">&lt;</span> x     <span class="fu">=</span> <span class="dt">Node</span> y t1 (insert x t2)</a>
<a class="sourceLine" id="cb90-5" title="5">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">Node</span> y (insert x t1) t2</a></code></pre></div>
<p>This code shows a new, syntactic feature: Pattern guards! These are Boolean expressions that you can use to further restrict when a case is taken. The third case in this function definition is only used if <code>y &lt; x</code>, otherwise the following cases are tried. Of course this could be written using <code>if … then … else …</code>, but the readability and aesthetics are better with pattern guards. The value <code>otherwise</code> is simply <code>True</code>, but this reads better.</p>
<div class="Exercise">
<p>Consider the following definition:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb91-1" title="1"><span class="kw">data</span> <span class="dt">Wat</span> <span class="fu">=</span> <span class="dt">Wat</span> <span class="dt">Wat</span></a></code></pre></div>
<p>Is this legal? What does it mean? Which occurrences of <code>Wat</code> are terms, and which are types? Can you define a value of type <code>Wat</code>?</p>
</div>
<div class="Solution">
<p>This type is legal. Every value of type <code>Wat</code> is built from the constructor <code>Wat</code>, applied to another value of type <code>Wat</code>. So, unless there are exceptions or nontermination around, it is just an infinite tower of <code>Wat</code>s:</p>
<pre><code>wat :: Wat
wat = Wat wat</code></pre>
</div>
</section>
<section id="polymorphic-data-types" class="level3">
<h3><span class="header-section-number">2.6.4</span> Polymorphic data types</h3>
<p>The tree data type declared in the previous section ought to be useful not just for integers, but maybe for any type. But it would be seriously annoying to have to create a new tree data type for each type we want to store in the tree. Therefore, we haven have <em>polymorphic data types</em>. In the example of the tree, we can write:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb93-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<p>You may remember that the <code>a</code> here ought to be a type variable, because it occurs in the place of a type, but is lower-case. When we want to use this tree data type at a concrete type, say <code>Integer</code>, we simply write <code>Tree Integer</code>:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb94-1" title="1"><span class="ot">insert ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span></a></code></pre></div>
<p>The actual code of the function does not change.</p>
<p>We can also write functions that work on polymorphic trees, i.e. which we can use on <em>any</em> <code>Tree</code>, no matter what type the values in the nodes are. A good example is:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb95-1" title="1"><span class="ot">size ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb95-2" title="2">size <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb95-3" title="3">size (<span class="dt">Node</span> _ t1 t2) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> size t1 <span class="fu">+</span> size t2</a></code></pre></div>
<p>Again, parametricity makes the type signature of such a function more useful than it seems at first: Just from looking at the type signature of <code>size</code> we <em>know</em> that this function does not look at the values stored in the nodes. Together with the name, that is really all the documentation we might need. Compare this to <code>size :: Tree Integer -&gt; Integer</code> – now it could just as well be that this function includes the number stored in the node in the result somehow.</p>
</section>
<section id="functions-in-data-types" class="level3">
<h3><span class="header-section-number">2.6.5</span> Functions in data types ★</h3>
<p>Maybe this is obvious to you, after the emphasis on functions in the first chapter, but it is still worth pointing out that data type can also store functions. This blurs the distinction between data and code some more, as this nice example shows:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb96-1" title="1"><span class="kw">data</span> <span class="dt">Stream</span> a b</a>
<a class="sourceLine" id="cb96-2" title="2">    <span class="fu">=</span> <span class="dt">NeedInput</span> (a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a b)</a>
<a class="sourceLine" id="cb96-3" title="3">    <span class="fu">|</span> <span class="dt">HasOutput</span> b (<span class="dt">Stream</span> a b)</a>
<a class="sourceLine" id="cb96-4" title="4">    <span class="fu">|</span> <span class="dt">Done</span></a></code></pre></div>
<p>The type <code>Stream a b</code> models a state machine that consumes values of type <code>a</code>, produces values of type <code>b</code>, and maybe eventually stops. Such a machine is in one of three states:</p>
<ol type="1">
<li>Waiting for input. This uses the <code>NeedInput</code> constructor, which carries a <em>function</em> that consumes a type of value <code>a</code> and returns the new state of the machine.</li>
<li>Producing output. This uses the <code>HasOutput</code> constructor, which stores the output value of type <code>b</code>, and the subsequent state of the machine.</li>
<li><code>Done</code>.</li>
</ol>
<p>We can create a state machine that does run-length encoding this way. This one does not ever stop, but that’s fine:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb97-1" title="1"><span class="ot">rle ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Stream</span> a (<span class="dt">Integer</span>,a)</a>
<a class="sourceLine" id="cb97-2" title="2">rle <span class="fu">=</span> <span class="dt">NeedInput</span> rle_start</a>
<a class="sourceLine" id="cb97-3" title="3"></a>
<a class="sourceLine" id="cb97-4" title="4"><span class="ot">rle_start ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a (<span class="dt">Integer</span>, a)</a>
<a class="sourceLine" id="cb97-5" title="5">rle_start x <span class="fu">=</span> <span class="dt">NeedInput</span> (rle_count x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb97-6" title="6"></a>
<a class="sourceLine" id="cb97-7" title="7"><span class="ot">rle_count ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a (<span class="dt">Integer</span>, a)</a>
<a class="sourceLine" id="cb97-8" title="8">rle_count x n x&#39; <span class="fu">|</span> x <span class="fu">==</span> x&#39; <span class="fu">=</span> <span class="dt">NeedInput</span> (rle_count x (n <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb97-9" title="9">                 <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">HasOutput</span> (n, x) (rle_start x&#39;)</a></code></pre></div>
</section>
</section>
<section id="predefined-data-types" class="level2">
<h2><span class="header-section-number">2.7</span> Predefined data types</h2>
<p>We intentionally discussed the mechanisms of algebraic data types first, so that we can explain the most common data types in the standard library easily.</p>
<section id="booleans" class="level3">
<h3><span class="header-section-number">2.7.1</span> Booleans ★</h3>
<p>As mentioned before, the values <code>True</code> and <code>False</code> are simply the constructors of a data type defined as</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb98-1" title="1"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span></a></code></pre></div>
<p>There is nothing magic about the definition of <code>Bool</code>. But this type plays a special role because of the <code>if … then … else …</code> construct, and because of the pattern guards seen before.</p>
</section>
<section id="maybe" class="level3">
<h3><span class="header-section-number">2.7.2</span> <code>Maybe</code></h3>
<p>A very common use case for algebraic data types is to capture the idea of a type whose values “maybe contain nothing, or just a value of type <code>a</code>”. Because this is so common, such a data type is predefined:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb99-1" title="1"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</a></code></pre></div>
<p>You might see <code>Maybe</code>, for example, in the return type of a function that deserializes a binary or textual representation of a type, for example:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb100-1" title="1"><span class="ot">parseFoo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Foo</span></a></code></pre></div>
<p>Such an operation can fail, and if the input is invalid, it would return <code>Nothing</code>. As a user of such a function, the only way to get to the value of type <code>a</code> therein is to pattern-match on the result, which forces me to think about and handle the case where the result is <code>Nothing</code>.</p>
<p>This is much more robust than the common idiom in C, where you have to remember to check for particular error values (-1, or <code>NULL</code>), or Go, where you get both a result and a separate error code, but you can still be lazy and use the result without checking the error code.</p>
<p>A big part of Haskell’s reputation as a language that makes it easier to write correct code relies on the use of data types to precisely describe the values you are dealing with.</p>
<div class="Exercise">
<p>How many values are there of type <code>Maybe (Maybe Bool)</code>. When can it be useful to nest <code>Maybe</code> in that way?</p>
</div>
<div class="Solution">
<p>There are four: <code>Nothing</code>, <code>Just Nothing</code>, <code>Just False</code> and <code>Just True</code>. It can be useful if, for example, the outer <code>Maybe</code> indicates whether some input was <em>valid</em>, whereas <code>Just Nothing</code> could indicate that the input was valid, but empty. But arguably this is not best practice, and dedicated data types with more speaking names could be preferred here.</p>
</div>
</section>
<section id="either" class="level3">
<h3><span class="header-section-number">2.7.3</span> <code>Either</code> ★</h3>
<p>With maybe we can express “one or none”. Sometimes we want “one or another” type. For this, the standard library provides</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb101-1" title="1"><span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="dt">Left</span> a <span class="fu">|</span> <span class="dt">Right</span> b</a></code></pre></div>
<p>Commonly, this type is used for computations that can fail, but that provide some useful error messages when they fail:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb102-1" title="1"><span class="ot">parseFoo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Foo</span></a></code></pre></div>
<p>This gives us the same robustness benefits of <code>Maybe</code>, but also a more helpful error messages. If used in this way, then the <code>Left</code> value is always used for the error or failure case, and the <code>Right</code> value for when everything went all right.</p>
</section>
<section id="tuples" class="level3">
<h3><span class="header-section-number">2.7.4</span> Tuples</h3>
<p>Imagine you are writing a function that wants to return two numbers – say, the last digit the rest of the number. The way to do that that you know so far would require defining a data type:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb103-1" title="1"><span class="kw">data</span> <span class="dt">TwoIntegers</span> <span class="fu">=</span> <span class="dt">TwoIntegers</span> <span class="dt">Integer</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb103-2" title="2"><span class="ot">splitLastDigit ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">TwoIntegers</span></a>
<a class="sourceLine" id="cb103-3" title="3">splitLastDigit n <span class="fu">=</span> <span class="dt">TwoIntegers</span> (n <span class="ot">`div`</span> <span class="dv">10</span>) (n <span class="ot">`mod`</span> <span class="dv">10</span>)</a></code></pre></div>
<p>Clearly, the concept of “passing around two values together“ is not particularly tied to <code>Integer</code>, and we can use polymorphism to generalize this definition:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb104-1" title="1"><span class="kw">data</span> <span class="dt">Two</span> a b <span class="fu">=</span> <span class="dt">Two</span> a b</a>
<a class="sourceLine" id="cb104-2" title="2"><span class="ot">splitLastDigit ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Two</span> <span class="dt">Integer</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb104-3" title="3">splitLastDigit n <span class="fu">=</span> <span class="dt">Two</span> (n <span class="ot">`div`</span> <span class="dv">10</span>) (n <span class="ot">`mod`</span> <span class="dv">10</span>)</a></code></pre></div>
<p>And because this is so useful, Haskell comes with built-in support for such pairs, including a nice and slim syntax:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb105-1" title="1"><span class="kw">data</span> (a,b) <span class="fu">=</span> (a,b) <span class="co">-- morally this is how it is defined</span></a>
<a class="sourceLine" id="cb105-2" title="2"><span class="ot">splitLastDigit ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb105-3" title="3">splitLastDigit n <span class="fu">=</span> (n <span class="ot">`div`</span> <span class="dv">10</span>, n <span class="ot">`mod`</span> <span class="dv">10</span>)</a></code></pre></div>
<p>Besides tuples, which store two values, there are triples, quadruples and, in general, n-tuples of any size you might encounter. But really, if these tuples get larger than two or three, the code starts to smell.</p>
<p>Their size is always fixed and statically known at compile time, and you can have values of different types as components of the tuple. This distinguishes them from the lists we will see shortly.</p>
<div class="Exercise">
<p>How could you represent the Riemann numbers from the previous section using only these predefined data types?</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb106-1" title="1"><span class="dt">Maybe</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)</a></code></pre></div>
</div>
<p>Useful predefined functions related to tuples are</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb107-1" title="1"><span class="fu">fst</span><span class="ot"> ::</span> (a,b) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb107-2" title="2"><span class="fu">snd</span><span class="ot"> ::</span> (a,b) <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>and because of their type I do not have to tell you what they do.</p>
</section>
<section id="the-unit-type" class="level3">
<h3><span class="header-section-number">2.7.5</span> The unit type</h3>
<p>There is also a zero-tuple, so to say: The unit type written <code>()</code> with only the value <code>()</code>:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb108-1" title="1"><span class="kw">data</span> () <span class="fu">=</span> () <span class="co">-- morally this is how it is defined</span></a></code></pre></div>
<p>While this does not look very useful yet, we will see that it plays a crucial role later. Until then, you can think of it as a good choice when we have something polymorphic, but we do not actually need an “interesting” type there.</p>
<div class="Exercise">
<p>Write functions <code>fromEitherUnit :: Either () a -&gt; Maybe a</code> and <code>toEitherUnit :: Maybe a -&gt; Either () a</code> that are inverses to each other. In one of these type signatures you can replace <code>()</code> with a new type variable <code>b</code>, and still implement the function. In which one? Why?</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb109-1" title="1"><span class="ot">fromEitherUnit ::</span> <span class="dt">Either</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb109-2" title="2">fromEitherUnit (<span class="dt">Left</span> ()) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb109-3" title="3">fromEitherUnit (<span class="dt">Right</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb109-4" title="4"></a>
<a class="sourceLine" id="cb109-5" title="5"><span class="ot">toEitherUnit ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> () a</a>
<a class="sourceLine" id="cb109-6" title="6">toEitherUnit <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Left</span> ()</a>
<a class="sourceLine" id="cb109-7" title="7">toEitherUnit (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Right</span> x</a></code></pre></div>
<p>We can make <code>fromEitherUnit</code> more polymorphic; it can simply ignore the argument to <code>Left</code>. We cannot do this in <code>toEitherUnit</code>: we would not have a value of type <code>b</code> at hand to pass to <code>Left</code>.</p>
</div>
</section>
<section id="lists" class="level3">
<h3><span class="header-section-number">2.7.6</span> Lists</h3>
<p>In the previous section we defined trees using a recursive data type. It should be obvious that we can define lists in a very analogous way:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb110-1" title="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Empty</span> <span class="fu">|</span> <span class="dt">Link</span> a (<span class="dt">List</span> a)</a></code></pre></div>
<p>This data structure is so ubiquitous in functional programming that it not only comes with the standard library, it also has very special, magic syntax:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb111-1" title="1"><span class="kw">data</span> [a] <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]</a></code></pre></div>
<p>In words: The type <code>[a]</code> is the type of lists with values of type <code>a</code>. Such a list is either the empty list, written as <code>[]</code>, or it is a non-empty list containing of a head <code>x</code> of type <code>a</code>, and a tail <code>xs</code>, and is written as <code>x:xs</code>. Note that the constructor <code>(:)</code>, called “cons”, is using operator syntax.</p>
<p>There is more special syntax for lists:</p>
<ol type="1">
<li>Finite lists can be written as <code>[1, 2, 3]</code> instead of <code>1 : 2 : 3 : []</code>.</li>
<li>Lists of numbers can be enumerated, e.g. <code>[1..10]</code>, or <code>[0,2..10]</code>, or even (due to laziness) <code>[1..]</code>.</li>
<li>List comprehensions look like <code>[ (x,y) | x &lt;- xs, y &lt;- ys, x &lt; y ]</code>, reminiscent of the set comprehension syntax from mathematics. We will not discuss them now, I just wanted to show them and tell you what to search for.</li>
</ol>
<p>Common operations on lists worth knowing are <code>(++)</code> to concatenate two lists.</p>
<p>Lists are very useful for many applications, but they are not a particularly high-performance data structure – random access and concatenation is expensive, and they use quite a bit of memory. Depending on the application, other types like arrays/vectors, finger trees, difference lists might be more suitable.</p>
</section>
<section id="characters-and-strings" class="level3">
<h3><span class="header-section-number">2.7.7</span> Characters and strings ★</h3>
<p>Unexpectedly, Haskell has built-in support for characters and text. A single character has type <code>Char</code>, and is written in single quotes, e.g. <code>'a'</code>, <code>'☃'</code>, <code>'\''</code>, <code>'\0'</code>, <code>'\xcafe'</code>. These character are Unicode code points, and not just 7 or 8 bit characters.</p>
<p>The built-in type <code>String</code> is just an alias for <code>[Char]</code>, i.e. a list of characters. Haskell supports special built-in syntax for strings, using double quotes, but this is just syntactic sugar to the list syntax:</p>
<pre><code>Prelude&gt; &quot;hello&quot;
&quot;hello&quot;
Prelude&gt; [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]
&quot;hello&quot;
Prelude&gt; &#39;h&#39;:&#39;e&#39;:&#39;l&#39;:&#39;l&#39;:&#39;o&#39;:[]
&quot;hello&quot;</code></pre>
<p>Because <code>String</code> is built on the list type, all the usual list operations, in particular <code>++</code> for concatenation, work on strings as well.</p>
<p>But <code>String</code> also has the same performance issues as lists: While it is fine to use them in non-critical parts of the code (diagnostic and error messages, command line and configuration file parsing, filenames), <code>String</code> is usually the wrong choice if large amounts of strings need to be processed, e.g. in a templating library. Additionally libraries provide more suitable data structures, in particular <code>ByteString</code> for binary data and <code>Text</code> for human-readable text.</p>
</section>
</section>
<section id="records" class="level2">
<h2><span class="header-section-number">2.8</span> Records ★</h2>
<p>Assume you want to create a type that represents an employee in a HR database. There are a fair number of field to store – name, date of birth, employee number, room, login handle, public key etc. You could use a tuple with many fields, or create your own data type with a constructor with many fields, but either way you will have to address the various fields by their position, which is verbose, easy to get wrong, and hard to extend.</p>
<p>In such a case, you can use records. These allow you to give names to the <em>field</em> of a constructor, and get some convenience functions along the way. The syntax to declare the record is</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb113-1" title="1"><span class="kw">data</span> <span class="dt">Employee</span> <span class="fu">=</span> <span class="dt">Employee</span></a>
<a class="sourceLine" id="cb113-2" title="2">    {<span class="ot"> name ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb113-3" title="3">    ,<span class="ot"> room ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb113-4" title="4">    ,<span class="ot"> pubkey ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb113-5" title="5">    }</a></code></pre></div>
<p>In terms of the constructor <code>Employee</code>, this is equivalent to</p>
<pre><code>data Employee = Employee String Integer ByteString</code></pre>
<p>and it is always possible to use <code>Employee</code> as a normal prefix function in terms and patterns. But the record syntax declaration enables the following nicer syntaxes:</p>
<ol type="1">
<li><p>Record creation: Instead of <code>Employee n r p</code> you can write <code>Employee { name = n; room = r; pubkey = p }</code>, and of course the order of the fields is irrelevant.</p></li>
<li><p>Record pattern matching. You can also write <code>Employee { name = n; room = r; pubkey = p }</code> in a pattern, to match on <code>Employee</code> and get <code>n</code>, <code>r</code> and <code>p</code> into scope.</p></li>
<li><p>Record update syntax: If we have <code>e :: Employee</code>, then <code>e { room = r' }</code> is like an <code>Employee</code> and all fields are the same as <code>e</code> with the exception of <code>room</code>.</p></li>
<li><p>The names of the fields are available as getters, i.e. after the above definition of <code>Employee</code>, there is a function <code>name :: Employee -&gt; String</code> etc.</p></li>
</ol>
<p>Curiously, the record creation or update syntax binds closer than function applications: <code>g x { f = y }</code> is <code>g (x { f = y })</code>, and <em>not</em> <code>(g x) { f = y }</code>.</p>
<p>With the language extension <code>RecordWildCards</code> enabled, it is even possible to write <code>Employee{..}</code> in a pattern, and get <em>all</em> fields of the employee record into scope, as variables, as if one had written <code>Employee { name = name; room = room; pubkey = pubkey }</code> (although some say that’s bad style, because it is too implicit).</p>
</section>
<section id="newtypes" class="level2">
<h2><span class="header-section-number">2.9</span> Newtypes ★</h2>
<p>Sometimes you will see a type declaration that uses <code>newtype</code> instead of <code>data</code>:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb115-1" title="1"><span class="kw">newtype</span> <span class="dt">Riemann</span> <span class="fu">=</span> <span class="dt">Riemann</span> (<span class="dt">Maybe</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>))</a></code></pre></div>
<p>For all purposes relevant to us so far you can mentally replace <code>newtype</code> with <code>data</code>. There are difference in memory representation (a <code>newtype</code> is “free” in some sense), but none that relevant at our current level.</p>
</section>
<section id="type-synonyms" class="level2">
<h2><span class="header-section-number">2.10</span> Type synonyms ★</h2>
<p>Haskell allows you to introduce new names for existing types. One example is the type <code>String</code>, which is defined as</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb116-1" title="1"><span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</a></code></pre></div>
<p>With this declaration, you can use <code>String</code> instead of <code>[Char]</code> in your type signatures. They are completely interchangeable, and a value of type <code>String</code> is still just a list of characters.</p>
<p>So type synonyms do not introduce any kind of type safety, they merely make types more readable.</p>
</section>
<section id="haddock" class="level2">
<h2><span class="header-section-number">2.11</span> Haddock ★</h2>
<p>Because knowing the type of a function is already a big step towards understanding what it does, the usual way of documenting a Haskell API is very much centered around types. The tool <code>haddock</code> creates HTML pages from Haskell source files that list all functions with their type, and – if present – the documentation that is attached to it via a comment.</p>
<p>For Haskell libraries hosted in the central package repository <em>Hackage</em>, this documentation is also provided. For example, you can learn all about the types and functions that are available by default by reading the <a href="https://hackage.haskell.org/package/base/docs/Prelude.html">haddock page for the prelude</a>. (There is a bunch of noise there that might not be relevant to you, like long lists of “Instances”. You can skip over them.)</p>
<p>From this documentation you will also find links labeled “Source” that take you to the definition of a type or function in the source code, in a syntax-highlighted and crosslinked presentation of the source.</p>
</section>
</section>
<section id="code-structure-small-and-large" class="level1">
<h1><span class="header-section-number">3</span> Code structure small and large</h1>
<p>The next big topic we need to learn about are the ways with which the programmer structures the code. This happens on multiple levels</p>
<ul>
<li>in a function: intermediate results are named, local helper functions are defined.</li>
<li>within a file: functions, type signatures, and documentation is arranged.</li>
<li>within a project (library, package): code is spread out in different files,and imported from other files.</li>
<li>between projects: packages are versioned, equipped with meta-data, and depend on each other.</li>
</ul>
<section id="let-expressions" class="level2">
<h2><span class="header-section-number">3.1</span> <code>let</code>-expressions</h2>
<p>The most basic way of adding some structure within an expression is to give a name to a subexpression, and possibly use it later. So instead of</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb117-1" title="1">isMultipleOf3 x <span class="fu">=</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">3</span> <span class="fu">||</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">6</span> <span class="fu">||</span> fixEq sumDigits x <span class="fu">==</span> <span class="dv">9</span></a></code></pre></div>
<p>one could write</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb118-1" title="1">isMultipleOf3 x <span class="fu">=</span></a>
<a class="sourceLine" id="cb118-2" title="2">  <span class="kw">let</span> y <span class="fu">=</span> fixEq sumDigits x</a>
<a class="sourceLine" id="cb118-3" title="3">  <span class="kw">in</span> y <span class="fu">==</span> <span class="dv">3</span> <span class="fu">||</span> y <span class="fu">==</span> <span class="dv">6</span> <span class="fu">||</span> y <span class="fu">==</span> <span class="dv">9</span></a></code></pre></div>
<p>which is arguably easier to read.</p>
<p>Be careful: A <code>let</code> expression in Haskell can always be recursive, so</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb119-1" title="1">isMultipleOf3 x <span class="fu">=</span></a>
<a class="sourceLine" id="cb119-2" title="2">  <span class="kw">let</span> x <span class="fu">=</span> fixEq sumDigits x</a>
<a class="sourceLine" id="cb119-3" title="3">  <span class="kw">in</span> x <span class="fu">==</span> <span class="dv">3</span> <span class="fu">||</span> x <span class="fu">==</span> <span class="dv">6</span> <span class="fu">||</span> x <span class="fu">==</span> <span class="dv">9</span></a></code></pre></div>
<p>does <em>not</em> work as expected.</p>
<p>In such a <code>let</code> expression, you can also do pattern-matching, e.g. to unpack a tuple:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb120-1" title="1"><span class="ot">sumDigitsWith ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb120-2" title="2">sumDigitsWith f n</a>
<a class="sourceLine" id="cb120-3" title="3">  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="fu">=</span> f n</a>
<a class="sourceLine" id="cb120-4" title="4">  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb120-5" title="5">    <span class="kw">let</span> (r,d) <span class="fu">=</span> splitLastDigit n</a>
<a class="sourceLine" id="cb120-6" title="6">    <span class="kw">in</span> sumDigitsWith f r <span class="fu">+</span> f d</a></code></pre></div>
<p>This is a fine and innocent thing to do if the pattern is <em>irrefutable</em>, i.e. always succeeds, but is a code smell if it is a pattern that can fail, e.g. <code>Just x = something</code>. In the latter case, a <code>case</code> statement might be more appropriate.</p>
<p>We can also define whole functions in a <code>let</code>-expression, just like on the top level. This might improve the code of our run-length-encoding automaton:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb121-1" title="1"><span class="ot">rle ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Stream</span> a (<span class="dt">Integer</span>,a)</a>
<a class="sourceLine" id="cb121-2" title="2">rle <span class="fu">=</span></a>
<a class="sourceLine" id="cb121-3" title="3">  <span class="kw">let</span> start x <span class="fu">=</span> <span class="dt">NeedInput</span> (count x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb121-4" title="4">      count x n x&#39; <span class="fu">|</span> x <span class="fu">==</span> x&#39; <span class="fu">=</span> <span class="dt">NeedInput</span> (count x (n <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb121-5" title="5">                       <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">HasOutput</span> (n, x) (start x&#39;)</a>
<a class="sourceLine" id="cb121-6" title="6">  <span class="kw">in</span> <span class="dt">NeedInput</span> start</a></code></pre></div>
<p>One advantage of this is that the “internal” functions <code>start</code> and <code>count</code> are now no longer available from the outside, and so a reader of this code knows for sure that these are purely internal. We can also drop the <code>rle_</code> prefix.</p>
<p>Another important advantage is that such local functions have access to the parameters of the enclosing function. To see this in action, let us extend <code>rle</code> with a parameter that indicates a element of the stream that should make the automaton stop:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb122-1" title="1"><span class="ot">rle ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a (<span class="dt">Integer</span>,a)</a>
<a class="sourceLine" id="cb122-2" title="2">rle stop <span class="fu">=</span></a>
<a class="sourceLine" id="cb122-3" title="3">  <span class="kw">let</span> start x <span class="fu">|</span> x <span class="fu">==</span> stop <span class="fu">=</span> <span class="dt">Done</span></a>
<a class="sourceLine" id="cb122-4" title="4">              <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">NeedInput</span> (count x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb122-5" title="5">      count x n x&#39; <span class="fu">|</span> x <span class="fu">==</span> x&#39; <span class="fu">=</span> <span class="dt">NeedInput</span> (count x (n <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb122-6" title="6">                   <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">HasOutput</span> (n, x) (start x&#39;)</a>
<a class="sourceLine" id="cb122-7" title="7">  <span class="kw">in</span> <span class="dt">NeedInput</span> start</a></code></pre></div>
<p>In <code>start</code> we can now access <code>stop</code> just fine. If <code>start</code> and <code>count</code> were not local functions, then we would have to add <code>stop</code> as an explicit parameter to <em>both</em> local functions, significantly cluttering the code with administrative details.</p>
</section>
<section id="where-clauses" class="level2">
<h2><span class="header-section-number">3.2</span> <code>where</code>-clauses ★</h2>
<p>I think few syntactic features show that Haskell’s syntax is designed with readability in mind, valuing that higher than syntactic minimalism, as well as the <code>where</code> clauses.</p>
<p>Looking the previous version of the <code>rle</code> program, a very picky reader might complain that it is annoying to have to first read past <code>start</code> and <code>count</code> to see the last line, when the last line tells the reader how it all starts, and thus should be first.</p>
<p>Therefore, the programmer has the option to use a <code>where</code>-clause instead of a <code>let</code> expression here. A <code>where</code>-clause is attached to a function equation (or, more rarely, to a match in a <code>case</code> expression), has access to its parameters and – most crucially – is written after or below the right-hand side of the equation:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb123-1" title="1"><span class="ot">rle ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a (<span class="dt">Integer</span>,a)</a>
<a class="sourceLine" id="cb123-2" title="2">rle stop <span class="fu">=</span> <span class="dt">NeedInput</span> start</a>
<a class="sourceLine" id="cb123-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb123-4" title="4">    start x <span class="fu">|</span> x <span class="fu">==</span> stop <span class="fu">=</span> <span class="dt">Done</span></a>
<a class="sourceLine" id="cb123-5" title="5">            <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">NeedInput</span> (count x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb123-6" title="6">    count x n x&#39; <span class="fu">|</span> x <span class="fu">==</span> x&#39; <span class="fu">=</span> <span class="dt">NeedInput</span> (count x (n <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb123-7" title="7">                 <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">HasOutput</span> (n, x) (start x&#39;)</a></code></pre></div>
<p>It is not a huge change, but one that – in my humble opinion – improves readability by a small but noticeable bit.</p>
<p>If you have a function with multiple guards on one equation, such as <code>start</code>, then a <code>where</code> clause would scope over all such guards. So we could write</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb124-1" title="1"><span class="ot">sumDigitsWith ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb124-2" title="2">sumDigitsWith f n</a>
<a class="sourceLine" id="cb124-3" title="3">  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="fu">=</span> f d</a>
<a class="sourceLine" id="cb124-4" title="4">  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> sumDigitsWith f r <span class="fu">+</span> f d</a>
<a class="sourceLine" id="cb124-5" title="5">  <span class="kw">where</span> (r,d) <span class="fu">=</span> splitLastDigit n</a></code></pre></div>
<p>(note that <code>d</code> is used in both right-hand sides) if we wanted.</p>
</section>
<section id="comments" class="level2">
<h2><span class="header-section-number">3.3</span> Comments ★</h2>
<p>Like every programming language, Haskell supports comments. There are line comments and multi-line comments:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb125-1" title="1">answer <span class="fu">=</span> <span class="dv">42</span> <span class="co">-- but what is the question?</span></a>
<a class="sourceLine" id="cb125-2" title="2"></a>
<a class="sourceLine" id="cb125-3" title="3"><span class="co">{-</span></a>
<a class="sourceLine" id="cb125-4" title="4"><span class="co">In the following code, we write a function that correctly tells</span></a>
<a class="sourceLine" id="cb125-5" title="5"><span class="co">us whether a Turing machine halts:</span></a>
<a class="sourceLine" id="cb125-6" title="6"><span class="co">-}</span></a>
<a class="sourceLine" id="cb125-7" title="7"><span class="ot">halts ::</span> <span class="dt">TuringMachine</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb125-8" title="8">halts turing_machine <span class="fu">=</span> halts turing_machine</a></code></pre></div>
<p>The <code>haddock</code> Haskell documentation tool uses specially marked comments for documentation, so the above could better be written as (note the vertical bar):</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb126-1" title="1"><span class="co">{- |</span></a>
<a class="sourceLine" id="cb126-2" title="2"><span class="co">In the following code, we write a function that correctly tells</span></a>
<a class="sourceLine" id="cb126-3" title="3"><span class="co">us whether a turing machine halts:</span></a>
<a class="sourceLine" id="cb126-4" title="4"><span class="co">-}</span></a>
<a class="sourceLine" id="cb126-5" title="5"><span class="ot">halts ::</span> <span class="dt">TuringMachine</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb126-6" title="6">halts turing_machine <span class="fu">=</span> halts turing_machine</a></code></pre></div>
</section>
<section id="the-structure-of-a-module" class="level2">
<h2><span class="header-section-number">3.4</span> The structure of a module</h2>
<p>As we zoom out one step, we get to look at a Haskell file as a whole. In Haskell, every file is also a Haskell <em>module</em>, and modules serve to provide namespacing support.</p>
<p>Normally, a Haskell module named <code>Foo.Bar.Baz</code> lives in a file <code>Foo/Bar/Baz.hs</code>, and begins with</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb127-1" title="1"><span class="kw">module</span> <span class="dt">Foo.Bar.Baz</span> <span class="kw">where</span></a></code></pre></div>
<p>Haskell module names are always capitalized.</p>
<p>If a file does not have such a header (which is usually only the case for experiments and the entry point of a Haskell program), then it is implicitly called <code>Main</code>. This is why the GHCi prompt says <code>Main&gt;</code> after loading such a file.</p>
<p>The rest of the module is are declarations: Values, functions, types, type synonyms etc. The important bit to know here is that the order of declarations is completely irrelevant: You can use functions you that are defined further down, you can mix type and function declarations, you can even separate the type signature of a function from its definition (but you have to keep multiple equations of one function together). This allows the author to sort functions by topic, or by relevance, rather than by dependency, and it is not uncommon to first show the main entry-point of a module, and put all the helper functions it uses below.</p>
</section>
<section id="importing-other-modules" class="level2">
<h2><span class="header-section-number">3.5</span> Importing other modules</h2>
<p>Obviously, the point of having multiple files of Haskell code is to use the code from one in the other. This is achieved using <code>import</code> statements, which <em>must</em> come right after the <code>module</code> header, and before any declarations.</p>
<p>So if we have a file <code>Target.hs</code> with content</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb128-1" title="1"><span class="kw">module</span> <span class="dt">Target</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb128-2" title="2"><span class="ot">who ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb128-3" title="3">who <span class="fu">=</span> <span class="st">&quot;world&quot;</span></a></code></pre></div>
<p>and another file <code>Tropes.hs</code> with content</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb129-1" title="1"><span class="kw">module</span> <span class="dt">Tropes</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb129-2" title="2"></a>
<a class="sourceLine" id="cb129-3" title="3"><span class="kw">import</span> <span class="dt">Target</span></a>
<a class="sourceLine" id="cb129-4" title="4"></a>
<a class="sourceLine" id="cb129-5" title="5"><span class="ot">greeting ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb129-6" title="6">greeting <span class="fu">=</span> <span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> who <span class="fu">++</span> <span class="st">&quot;!&quot;</span></a></code></pre></div>
<p>then the use of <code>who</code> in <code>greeting</code> refers to the definition in the file <code>Target.hs</code>.</p>
<p>We could also write</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb130-1" title="1"><span class="ot">greeting ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb130-2" title="2">greeting <span class="fu">=</span> <span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> Target.who <span class="fu">++</span> <span class="st">&quot;!&quot;</span></a></code></pre></div>
<p>and use the <em>fully qualified</em> name of <code>who</code>. This can be useful for disambiguation, or simply for clarity. There must not be spaces around the period, or else it would refer to the composition operator.</p>
<p>If we only ever intend to use the things we import from a module in their qualified names, we can use a <em>qualified</em> import:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb131-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Target</span></a></code></pre></div>
<p>And if the module has a long name, we can shorten it:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb132-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Target</span> <span class="kw">as</span> <span class="dt">T</span></a></code></pre></div>
<p>and write <code>T.who</code>. This is a common idiom for modules like <code>Data.Text</code> that export many names that would otherwise clash with names from the prelude.</p>
<p>The standard library, called <code>base</code>, comes with <a href="http://hackage.haskell.org/package/base">many modules you can import</a> in addition to the <code>Prelude</code> module, which is always imported implicitly.</p>
</section>
<section id="import-lists" class="level2">
<h2><span class="header-section-number">3.6</span> Import lists ★</h2>
<p>If we do not want to import <em>all</em> names of another module, we can import just a specific selection, e.g.:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb133-1" title="1"><span class="kw">import</span> <span class="dt">Data.Maybe</span> (mapMaybe)</a></code></pre></div>
<p>This makes it easier for someone reading the code to locate where a certain function is from, and it makes the code more robust against breakage when a new version of the other module starts exporting additional names. These would not silently override other names, but cause compiler errors about ambiguous names.</p>
<p>When including an operator in this list, include it in parenthesis:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb134-1" title="1"><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</a></code></pre></div>
<p>You can import types just as well, just include them in the list. To import <em>constructors</em> (which look like types), you have to list them after the type they belong to. So if we put our definitions of <code>Complex</code> and <code>Riemann</code> into a file <code>Riemann.hs</code>, namely</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb135-1" title="1"><span class="kw">module</span> <span class="dt">Riemann</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb135-2" title="2"><span class="kw">data</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">C</span> <span class="dt">Integer</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb135-3" title="3"><span class="kw">data</span> <span class="dt">Riemann</span> <span class="fu">=</span> <span class="dt">Complex</span> <span class="dt">Complex</span> <span class="fu">|</span> <span class="dt">Infinity</span></a></code></pre></div>
<p>then you can import everything using</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb136-1" title="1"><span class="kw">import</span> <span class="dt">Riemann</span> (<span class="dt">Complex</span>(<span class="dt">C</span>), <span class="dt">Riemann</span>(<span class="dt">Complex</span>, <span class="dt">Infinity</span>))</a></code></pre></div>
<p>or, shorter,</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb137-1" title="1"><span class="kw">import</span> <span class="dt">Riemann</span> (<span class="dt">Complex</span>(..), <span class="dt">Riemann</span>(..))</a></code></pre></div>
</section>
<section id="export-lists-and-abstract-types" class="level2">
<h2><span class="header-section-number">3.7</span> Export lists and abstract types ★</h2>
<p>You can not only restrict what you import, but also what you export. To do so, you list the names of functions, types, etc. that you want to export after the module name:</p>
<pre><code>module Riemann (Complex, Riemann(..)) where
…</code></pre>
<p>A short export list is a great help when trying to understand the role and purpose of a module: If it only exports one or a small number of functions, it is clear that these are the (only) entry points to the code, and that all other declarations are purely internal.</p>
<p>By excluding the constructors of a data type from the export list, as we did in this example with the <code>Complex</code> type, we can make this type <em>abstract</em>: Users of our module now have no knowledge of the internal structure of <code>Complex</code>, and they are unable to create or arbitrarily inspect values of type <code>Complex</code>. Instead, they are only able to do so using the <em>other</em> functions that we export along with <code>Complex</code>. This way we can ensure certain invariant in our types – think of a search tree with the invariant that it is sorted – or reserve the ability to change the shape of the type without breaking depending code.</p>
<p>Proper user of abstract types greatly helps to make code more readable, more maintainable and more robust, quite similar to how polymorphism does it on a smaller scale.</p>
</section>
<section id="language-extensions" class="level2">
<h2><span class="header-section-number">3.8</span> Language extensions</h2>
<p>Haskell is a language with a reasonably precise specification, the <em>Haskell Report</em>. When someone mentions Haskell 98, they refer to Haskell as specified in the <a href="https://www.haskell.org/onlinereport/">Haskell Report from 1998</a>. There was one revision, the <a href="https://www.haskell.org/onlinereport/haskell2010/">Haskell Report from 2010</a>, with only rather small changes.</p>
<p>But Haskell developers and implementors wanted to add more and more features to the language. But the report was written, and the compiler writers wanted to support Haskell, as specified, by default. Therefore, the system of <em>language extensions</em> was introduced.</p>
<p>A language extension is a feature that extends Haskell98 in some way. It could add more syntactic sugar, additional features on the type system or enable whole meta-programming facilities. A Haskell source file needs to explicitly declare the extensions they are using, right at the top before the <code>module</code> header, and a typical Haskell file these days might start with a number of them, and look like this:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb139-1" title="1"><span class="ot">{-# LANGUAGE ApplicativeDo #-}</span></a>
<a class="sourceLine" id="cb139-2" title="2"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb139-3" title="3"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb139-4" title="4"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb139-5" title="5"><span class="ot">{-# LANGUAGE MonoLocalBinds #-}</span></a>
<a class="sourceLine" id="cb139-6" title="6"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb139-7" title="7"><span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span></a>
<a class="sourceLine" id="cb139-8" title="8"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb139-9" title="9"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb139-10" title="10"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb139-11" title="11"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a></code></pre></div>
<p>These language extensions (and there are many of them) are <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#language-options">documented in the GHC user’s guide</a>.</p>
<p>You can also enable language extensions on the GHCi prompt, e.g. using <code>:set -XRecordWildCards</code>.</p>
</section>
<section id="haskell-packages" class="level2">
<h2><span class="header-section-number">3.9</span> Haskell packages ★</h2>
<p>Zooming out some more, we come across packages: A <em>package</em> is a collection of modules that are bundled under a single package name. A package contains meta-data (name, version number, author, license…). Packages declare which other packages they depend upon, together with version ranges. All this meta-data can be found in the <em>Cabal file</em> called <code>foo.cabal</code> in the root directory of the project.</p>
<p>Almost all publicly available Haskell packages are hosted centrally on <a href="http://hackage.haskell.org/packages/">Hackage</a>, including the haddock-generated documentation and cross-linked source code. They can be easily installed using the <a href="https://www.haskell.org/cabal/"><code>cabal</code> tool</a>, or alternative systems like <a href="https://www.haskellstack.org/"><code>stack</code></a> or <a href="https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure"><code>nix</code></a>. The packages on Hackage cover many common needs and it is expected that a serious Haskell project depends on dozen of Haskell packages from Hackage.</p>
</section>
</section>
<section id="type-classes" class="level1">
<h1><span class="header-section-number">4</span> Type classes</h1>
<p>The language features we have seen so far can be found, with slight variations, in most functional programming languages. In this chapter, we will look at a feature that Haskell is particularly renown for: <em>Type classes</em>.</p>
<p>Let me start by pointing out what type classes are not: They are not classes as in object oriented programming, so please do not try to attempt to understand them by analogy to that.</p>
<p>Instead, type classes are a language feature that provides, in sequence of sophistication,</p>
<ul>
<li>overloading of operators and function,</li>
<li>implicit dependency injection,</li>
<li>polymorphism over types with structure, and</li>
<li>type-driven code synthesis.</li>
</ul>
<p>We have actually seen most of them:</p>
<section id="overloading" class="level2">
<h2><span class="header-section-number">4.1</span> Overloading</h2>
<p>Assume, for a moment, that <code>(==)</code> operator we have seen already only works on <code>Integer</code>. But surely, it is no problem to define equality on, say, <code>Complex</code> and <code>Riemann</code>:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb140-1" title="1"><span class="ot">eqComplex ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb140-2" title="2">eqComplex (<span class="dt">C</span> x1 y1) (<span class="dt">C</span> x2 y2) <span class="fu">=</span> x1 <span class="fu">==</span> x2 <span class="fu">&amp;&amp;</span> y1 <span class="fu">==</span> y2</a>
<a class="sourceLine" id="cb140-3" title="3"></a>
<a class="sourceLine" id="cb140-4" title="4"><span class="ot">eqRiemann ::</span> <span class="dt">Riemann</span> <span class="ot">-&gt;</span> <span class="dt">Riemann</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb140-5" title="5">eqRiemann (<span class="dt">Complex</span> c1) (<span class="dt">Complex</span> c2) <span class="fu">=</span> c1 <span class="ot">`eqComplex`</span> c2</a>
<a class="sourceLine" id="cb140-6" title="6">eqRiemann <span class="dt">Infinity</span> <span class="dt">Infinity</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb140-7" title="7">eqRiemann _ _ <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>Similarly, we can define comparisons, numeric operators etc. This is good enough to express most of the code that we want to write, but it is terribly verbose and annoying to remember the name of the right equality function, and have the type (in the name) be repeated all over the code.</p>
<p>So what we really want is to use the nice <code>(==)</code> syntax, but we want it to mean <em>different things at different types</em> – overloading!</p>
<p>In order to do that, we first have to declare that <code>(==)</code> is a function we can overload, by declaring a class with it as a method:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb141-1" title="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb141-2" title="2"><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Of course, the <code>Eq</code> class is already defined. From now on, I can use <code>(==)</code> with every type that is an <em>instance</em> of <code>Eq</code>. We can declare instances for <code>Complex</code> and <code>Riemann</code>:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb142-1" title="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Complex</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb142-2" title="2">    <span class="dt">C</span> x1 y1 <span class="fu">==</span> <span class="dt">C</span> x2 y2 <span class="fu">=</span> x1 <span class="fu">==</span> x2 <span class="fu">&amp;&amp;</span> y1 <span class="fu">==</span> y2</a>
<a class="sourceLine" id="cb142-3" title="3"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Riemann</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb142-4" title="4">    (<span class="fu">==</span>) <span class="fu">=</span> eqRiemann</a></code></pre></div>
<p>and with this in place, we can use <code>(==)</code> not only for <code>Integer</code>, but also <code>Complex</code> and <code>Riemann</code>. In fact, we can use <code>(==)</code> instead of <code>eqComplex</code> in the definition of <code>eqRiemann</code> – remember that the order of declarations is irrelevant in a Haskell module.</p>
<p>Now can hopefully better understand the type signature of <code>(==)</code>:</p>
<pre><code>Prelude&gt; :t (==)
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</code></pre>
<p>The part after the <code>=&gt;</code> indicates the argument and return types of <code>(==)</code>. But the type variable <code>a</code> cannot just be any type (as it was the case with fully polymorphic functions like <code>const</code>): It has to be a type that is an instance of the <code>Eq</code> class. This is expressed by the <em>constraints</em> on the left of the <code>=&gt;</code>.</p>
<div class="Exercise">
<p>Write an <code>Eq</code> instance for <code>Employee</code>, using record accessors. Is there a problem with this code?</p>
</div>
<div class="Solution">
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb144-1" title="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Employee</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb144-2" title="2">    e1 <span class="fu">==</span> e2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb144-3" title="3">        name e1 <span class="fu">==</span> name e2 <span class="fu">&amp;&amp;</span></a>
<a class="sourceLine" id="cb144-4" title="4">        room e1 <span class="fu">==</span> room e2 <span class="fu">&amp;&amp;</span></a>
<a class="sourceLine" id="cb144-5" title="5">        pubkey e1 <span class="fu">==</span> pubkey e2</a></code></pre></div>
<p>The problem is: If the record gains additional fields, this code still compiles, and the programmer is not warned that they should update it. By not using the record accessors, but instead normal constructor syntax, this can be avoided:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb145-1" title="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Employee</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb145-2" title="2">    <span class="dt">Employee</span> n1 r1 p1 <span class="fu">==</span> <span class="dt">Employee</span> n2 r2 pr <span class="fu">=</span></a>
<a class="sourceLine" id="cb145-3" title="3">        n1 <span class="fu">==</span> n2 <span class="fu">&amp;&amp;</span> r1 <span class="fu">==</span> r2 <span class="fu">&amp;&amp;</span> p1 <span class="fu">==</span> p2</a></code></pre></div>
</div>
</section>
<section id="implicit-dependency-injection" class="level2">
<h2><span class="header-section-number">4.2</span> Implicit dependency injection</h2>
<p>Sometimes type classes are used for implicit dependency injection. Which is just a fancy way of saying “I don’t want to pass an extra argument and instead want the compiler do that implicitly for me, based on the types”.</p>
<p>Recall our definition of <code>fixEq</code>:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb146-1" title="1"><span class="ot">fixEq ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb146-2" title="2">fixEq f x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> f x <span class="kw">then</span> x <span class="kw">else</span> fixEq f (f x)</a></code></pre></div>
<p>which “iterates <code>f</code> on <code>x</code> until the value is equal to the one before.”. Compare this to the following version:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb147-1" title="1"><span class="ot">fixBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb147-2" title="2">fixBy p f x <span class="fu">=</span> <span class="kw">if</span> x <span class="ot">`p`</span> f x <span class="kw">then</span> x <span class="kw">else</span> fixEq p f (f x)</a></code></pre></div>
<p>This function iterates until a user-specified function tells it to stop. This might be useful for some iterative approximation algorithm, where we stop once the difference between subsequent approximations is smaller than some epsilon.</p>
<p>Note that this is a form of dependency injection: The caller of <code>fixBy</code> passes the dependency “stopping function” along. In general, this can be of course much more complex, e.g. a storage backend.</p>
<p>It is clearly more general than the other, as we can implement <code>fixEq</code> using <code>fixBy</code>, by specifying <code>p</code> to be equality:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb148-1" title="1"><span class="ot">fixEq ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb148-2" title="2">fixEq <span class="fu">=</span> fixBy (<span class="fu">==</span>)</a></code></pre></div>
<p>So whenever a parameter to a polymorphic function is, for the given concrete type, the same, on can use type classes and overloading to make this parameter selection implicit.</p>
<p>Note that just because one <em>can</em> do that, one does not have to. Often explicit arguments are easier to understand and maintain and more flexible (e.g. if you want different arguments at the same types). I consider this use of type classes less relevant than the other uses presented here.</p>
</section>
<section id="polymorphism-over-types-with-structure" class="level2">
<h2><span class="header-section-number">4.3</span> Polymorphism over types with structure</h2>
<p>Similar to the <code>Eq</code> type class, there is an <code>Ord</code> type class that overloads the comparisons operators <code>(&lt;)</code> <code>(&lt;=)</code>, <code>(&gt;)</code> and <code>(&gt;=)</code>.</p>
<p>Using them, we can define a predicate on polymorphic trees that checks whether the tree is sorted, i.e. every value is less than or equal to every value further right. One way of implementing this is:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb149-1" title="1"><span class="ot">everyNode ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb149-2" title="2">everyNode p (<span class="dt">Node</span> x t1 t2) <span class="fu">=</span> p x t1 t2 <span class="fu">&amp;&amp;</span> everyNode p t1 <span class="fu">&amp;&amp;</span> everyNode p t2</a>
<a class="sourceLine" id="cb149-3" title="3">everyNode _ <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb149-4" title="4"></a>
<a class="sourceLine" id="cb149-5" title="5"><span class="ot">everyValue ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb149-6" title="6">everyValue p <span class="fu">=</span> everyNode (\x _ _ <span class="ot">-&gt;</span> p x)</a>
<a class="sourceLine" id="cb149-7" title="7"></a>
<a class="sourceLine" id="cb149-8" title="8"><span class="ot">isSorted ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb149-9" title="9">isSorted <span class="fu">=</span> everyNode <span class="fu">$</span> \y t1 t2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb149-10" title="10">    everyValue (\x <span class="ot">-&gt;</span> x <span class="fu">&lt;=</span> y) t1 <span class="fu">&amp;&amp;</span></a>
<a class="sourceLine" id="cb149-11" title="11">    everyValue (\z <span class="ot">-&gt;</span> y <span class="fu">&lt;=</span> z) t2</a></code></pre></div>
<p>(Can you make sense of this code? It is a good exercise to make sure you can read this code. If you find this code to be inefficient, then you are right: It is algorithmically bad, but serves nicely as a high-level specification.)</p>
<p>Does this correctly implement the specification? Yes and no! If we have a tree of <code>Integer</code>, then <code>isSorted</code> will indeed return <code>True</code> if every element is smaller or equal to every element further on the right. But here is a counter example, for which we need to define a type:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb150-1" title="1"><span class="kw">data</span> <span class="dt">ABC</span> <span class="fu">=</span> <span class="dt">A</span> <span class="fu">|</span> <span class="dt">B</span> <span class="fu">|</span> <span class="dt">C</span> <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb150-2" title="2"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb150-3" title="3">  x <span class="fu">&lt;=</span> y <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb150-4" title="4">  <span class="dt">A</span> <span class="fu">&lt;=</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb150-5" title="5">  <span class="dt">B</span> <span class="fu">&lt;=</span> <span class="dt">C</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb150-6" title="6">  _ <span class="fu">&lt;=</span> _ <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>(You can ignore the <code>deriving Eq</code> for a moment). Now we can have a tree that is claimed to be sorted, but it is not!</p>
<pre><code>*Main&gt; isSorted (Node B (Node A Leaf Leaf) (Node C Leaf Leaf))
True
*Main&gt; A &lt;= C
False</code></pre>
<p>What is the problem here? The problem is not (really) with the code <code>isSorted</code>, but rather with the <code>Ord</code> instance for <code>ABC</code>: It does not behave as we would expect it to, in particular, it is not transitive:</p>
<pre><code>*Main&gt; (A &lt;= B &amp;&amp; B &lt;= C, A &lt;= C)
(True,False)</code></pre>
<p>And if we look at the <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Ord">documentation of the <code>Ord</code></a> type class, we see that any instance of <code>Ord</code> is expected to be, among other things, transitive. And indeed, most type classes come with additional requirements, or laws, that should hold for the instances.</p>
<p>In this sense, the constraint in the type signature of <code>isSorted</code> should not be read as “for any type <code>a</code> that implements the signature of the <code>Ord</code> type class…”, but rather as “for any type <code>a</code> that is ordered…”. Not the <em>interface</em> matters, but rather the <em>semantic meaning</em> behind it.</p>
<p>Conversely, if you come across a type class without any semantic meaning, i.e. one that just overloads a name, then that is clearly fishy. Nothing good will come out of a type class like, say</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb153-1" title="1"><span class="kw">class</span> <span class="dt">IntAble</span> a <span class="kw">where</span><span class="ot"> toInteger ::</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a></code></pre></div>
<p>if it does not also come with an abstract meaning that should be shared by all instances.</p>
<p>By the way, did you notice the <code>Eq</code> constraint in the head of the declaration of the <code>Ord</code> type class:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb154-1" title="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span></a></code></pre></div>
<p>This means that only types that are an instance of <code>Eq</code> may have an instance of <code>Ord</code>. The upshot is that a function with a <code>Ord a</code> constraint may also use <code>(==)</code>, without explicitly listing the <code>Eq</code> constraint.</p>
<div class="Exercise">
<p>Look up the <code>Semigroup</code> type class, and find its laws.</p>
</div>
<div class="Solution">
<p>The <code>Semigroup</code> type class is defined as</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb155-1" title="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb155-2" title="2"><span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>with the additional requirement that the <code>(&lt;&gt;)</code> operation is associative, and that <code>mempty</code> is its neutral element. (The <a href="http://hackage.haskell.org/package/base/docs/Data-Monoid.html">actual definition</a> has additional methods, not relevant here.)</p>
</div>
<div class="Exercise">
<p>Can you think of a <code>Semigroup (Tree a)</code> instance? Or maybe even more than one? How can you be sure it is a lawful instance?</p>
</div>
<div class="Solution">
<p>There are (at least) two sensible instances for the <code>Semigroup</code> type class for trees:</p>
<ol type="1">
<li><p>The first one concatenates two trees, so that an in-order traversal first visits the value of the left and then of the right tree:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb156-1" title="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb156-2" title="2">    <span class="dt">Leaf</span> <span class="fu">&lt;&gt;</span> t <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb156-3" title="3">    (<span class="dt">Node</span> x l r) t <span class="fu">=</span> <span class="dt">Node</span> x l (r <span class="fu">&lt;&gt;</span> t)</a></code></pre></div>
<p>There are variations of this code that are more likely to produce a balance tree – although then one has to think about whether associativity holds only when one considers different shapes of the same data equivalent (which is commonly the case for search trees).</p></li>
<li><p>Another one traverses both trees together, using a <code>Semigroup</code> instance for the elements to combine values that are present in the same position in both:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb157-1" title="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb157-2" title="2">    <span class="dt">Leaf</span> <span class="fu">&lt;&gt;</span> t <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb157-3" title="3">    t <span class="fu">&lt;&gt;</span> <span class="dt">Leaf</span> <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb157-4" title="4">    <span class="dt">Node</span> x l1 r1 <span class="fu">&lt;&gt;</span> <span class="dt">Node</span> y l2 r2 <span class="fu">=</span> <span class="dt">Node</span> (x <span class="fu">&lt;&gt;</span> y) (l1 <span class="fu">&lt;&gt;</span> l2) (r1 <span class="fu">&lt;&gt;</span> r2)</a></code></pre></div>
<p>Here, the instance head itself has a constraint: This instance for <code>Tree a</code> only exists if there is a <code>Semigroup</code> instance for the type of values.</p></li>
</ol>
<p>Which instance is the right one? That depends on the purpose of the <code>Tree</code> data structure in the code; and maybe neither is the right one, in which case it might be better to have <em>no</em> instance at all, and use other mechanisms to select the right behavior.</p>
</div>
<div class="Exercise">
<p>Given a function signature <code>summarize :: Monoid a =&gt; Tree a -&gt; a</code>, can you guess what it does? What would be the implementation you expect?</p>
<p>With that implementation, can you use <code>summarize</code> to distinguish trees that differ in shape, but have the same elements in the same order? What does this imply for search trees?</p>
</div>
<div class="Solution">
<p>One might expect this code:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb158-1" title="1"><span class="ot">summarize ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb158-2" title="2">summarize <span class="dt">Leaf</span> <span class="fu">=</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb158-3" title="3">summarize (<span class="dt">Node</span> x l r) <span class="fu">=</span> summarize l <span class="fu">&lt;&gt;</span> x <span class="fu">&lt;&gt;</span> summarize r</a></code></pre></div>
<p>(at least given everything we did so far considered in-order traversals.)</p>
<p>If we have two trees with the same elements in the same order, but in a different shape, e.g.</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb159-1" title="1">t1 <span class="fu">=</span> <span class="dt">Tree</span> x <span class="dt">Leaf</span> (<span class="dt">Tree</span> y <span class="dt">Leaf</span> (<span class="dt">Tree</span> z <span class="dt">Leaf</span>))</a>
<a class="sourceLine" id="cb159-2" title="2">t2 <span class="fu">=</span> <span class="dt">Tree</span> y (<span class="dt">Tree</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>) (<span class="dt">Tree</span> z <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a></code></pre></div>
<p>for some values <code>x</code>, <code>y</code> and <code>z</code>, then we will always have <code>summarize t1 = summarize t2</code>, assuming that the <code>Monoid</code> instance for the type of values is lawful. This is important if we use these trees as search trees, where the internal shape should be an implementation detail that should not be visible from the outside.</p>
</div>
</section>
<section id="type-driven-code-synthesis" class="level2">
<h2><span class="header-section-number">4.4</span> Type-driven code synthesis</h2>
<p>Let us turn to the most sophisticated use of type classes (within this lecture): Type driven code synthesis! Again, this is a fancy word for something rather simple, but it is very powerful, and a driving idiom for many problems in the Haskell space.</p>
<p>In the previous chapter we have seen a number of common types that can be combined to build larger types – <code>Maybe</code>, tuples, <code>Either</code>, list, etc. If there is functionality that we want to provide at many different types, then we can use type classes to describe how to get that functionality for each of these building blocks, assuming we have it for the argument types, and then the user automatically gets the functionality for any complex type they build.</p>
<p>Typical examples for such functionality are parsers, pretty-printers, serialization libraries, substitutions of sorts, random values, test case generation…</p>
<p>Let us define a type class that describes <em>finite</em> types, i.e. types with a finite number of values, and a function that returns the number of values in the type:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb160-1" title="1"><span class="kw">class</span> <span class="dt">Finite</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb160-2" title="2"><span class="ot">    size ::</span> <span class="dt">Integer</span></a></code></pre></div>
<p>Is this a good type class, i.e. does it have <em>meaning</em>? Yes, it does: When a type has an instance of <code>Finite</code>, it means that the type is finite, and that <code>size</code> designates the number of elements. Unfortunately Haskell does not prevent you from writing an instance that does not adhere to that, but that would then simply be wrong.</p>
<p>This definition is a bit weird: The type signature of <code>size</code> does not mention the type <code>a</code> anywhere. On the one hand, this makes sense: We do not need a concrete element in our hand to ask the question “how many elements are there in <code>a</code>”, nor do we expect to receive a concrete element. On the other hand, when we use <code>size</code> somewhere, how will the compiler know for which type we want it?</p>
<p>Therefore, this would be prohibited in plain Haskell. But as mentioned before, contemporary Haskell often uses language extensions supported by the compiler, and that is what we will do here, namely</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb161-1" title="1"><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></a>
<a class="sourceLine" id="cb161-2" title="2"><span class="ot">{-# LANGUAGE TypeApplications #-}</span></a>
<a class="sourceLine" id="cb161-3" title="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a></code></pre></div>
<p>(in <code>ghci</code> you can type <code>:set -XAllowAmbiguousTypes -XTypeApplications -XScopedTypeVariables</code>). Now this class declaration is accepted, and we can use the syntax <code>size @Bool</code> to say which instance to use.</p>
<p>Now we can start writing instances for some primitive types:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb162-1" title="1"><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Bool</span> <span class="kw">where</span> size <span class="fu">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb162-2" title="2"><span class="kw">instance</span> <span class="dt">Finite</span> () <span class="kw">where</span> size <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb162-3" title="3"><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Suit</span> <span class="kw">where</span> size <span class="fu">=</span> <span class="dv">4</span></a></code></pre></div>
<p>More interesting are the instances for the types that build on other types. These are not always <code>Finite</code>, but only if the types therein are themselves <code>Finite</code>, so we constrain the instance itself:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb163-1" title="1"><span class="kw">instance</span> <span class="dt">Finite</span> a <span class="ot">=&gt;</span> <span class="dt">Finite</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb163-2" title="2">    size <span class="fu">=</span> size <span class="fu">@</span>a <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb163-3" title="3"><span class="kw">instance</span> (<span class="dt">Finite</span> a, <span class="dt">Finite</span> b) <span class="ot">=&gt;</span> <span class="dt">Finite</span> (a,b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb163-4" title="4">    size <span class="fu">=</span> size <span class="fu">@</span>a <span class="fu">*</span> size <span class="fu">@</span>b</a>
<a class="sourceLine" id="cb163-5" title="5"><span class="kw">instance</span> (<span class="dt">Finite</span> a, <span class="dt">Finite</span> b) <span class="ot">=&gt;</span> <span class="dt">Finite</span> (<span class="dt">Either</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb163-6" title="6">    size <span class="fu">=</span> size <span class="fu">@</span>a <span class="fu">+</span> size <span class="fu">@</span>b</a></code></pre></div>
<p>Even the function type is finite, if both domain and codomain are finite:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb164-1" title="1"><span class="kw">instance</span> (<span class="dt">Finite</span> a, <span class="dt">Finite</span> b) <span class="ot">=&gt;</span> <span class="dt">Finite</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb164-2" title="2">    size <span class="fu">=</span> size <span class="fu">@</span>b <span class="fu">^</span> size <span class="fu">@</span>a</a></code></pre></div>
<p>Note that for obvious reasons we do not have an instance for <code>Integer</code>, or the list type.</p>
<p>Now that we have sown the seed, we want to reap the fruit: Whatever complex type we build out of these constructors, we can evaluate <code>size</code> that that type:</p>
<pre><code>Prelude&gt; size @(Maybe Bool)
3
Prelude&gt; size @(Suit -&gt; Bool)
16
Prelude&gt; size @(Suit -&gt; Bool, Bool -&gt; Suit)
256
Prelude&gt; size @((Suit -&gt; Suit) -&gt; Maybe Bool)
1390084523771447327649397867896613031142188508
0852913799160482443003607262976643594100176915
4109609521811665540548899435521</code></pre>
<p>The utility of such a <code>size</code> function is questionable (but not completely void), but I hope you understand the power behind this approach, and also recognize the pattern if you see in the wild.</p>
<p>In fact, instances of the <code>Eq</code> and <code>Ord</code> class for the container types like tuples and lists etc. are also instances of this pattern.</p>
</section>
<section id="interlude-kinds" class="level2">
<h2><span class="header-section-number">4.5</span> Interlude: Kinds ★</h2>
<p>This section is not directly related to type classes, but the concept of <em>kinds</em> shows up first here.</p>
<p>You might have already noticed that there is a fundamental difference between a type like <code>Bool</code> and a type like <code>Maybe</code>. The former has values, e.g. <code>True</code>, and it can be an argument or a return value of a function. That is not true for <code>Maybe</code>. There is no value that has type <code>Maybe</code>! Only when we say what type we maybe have, do we get a proper type. So <code>Maybe</code> is not a normal type in that sense, but <code>Maybe Bool</code> is, or in general <code>Maybe a</code> for any normal type <code>a</code>.</p>
<p>So what is <code>Maybe</code>? It is a type former! It takes a normal type, with values (like <code>Bool</code>) and creates a new normal type form it (namely <code>Maybe Bool</code>).</p>
<p>We can apply <code>Maybe</code> multiple times: <code>Maybe (Maybe Bool)</code> is also a normal type. But we cannot apply <code>Maybe</code> to itself: <code>Maybe Maybe</code> is nonsense.</p>
<p>This is all very similar to the term level, where <code>True</code> is a Boolean, but <code>not</code> is not a Boolean. But <code>not</code> can be applied to a Boolean, and <code>not True</code> is another Boolean. We can apply it multiple times <code>not (not True)</code>, but we cannot apply it to itself <code>not not</code>.</p>
<p>On the term level, terms have <em>types</em> that describe what compositions make sense and which compositions are disallowed. <code>True</code> has type <code>Bool</code>, and <code>not</code> has type <code>Bool -&gt; Bool</code>, which explains why you can apply <code>not</code> to <code>True</code>, but not to <code>not</code>.</p>
<p>We find the same on the type level: Types have <em>kinds</em> that describe which compositions make sense and which compositions are disallowed. <code>Bool</code> has kind <code>*</code> (pronounced “star” or simply type), and <code>Maybe</code> has kind <code>* -&gt; *</code>, which explains why you can apply <code>Maybe</code> to <code>Bool</code>, but not to <code>Maybe</code>.</p>
<p>The kind <code>*</code> is the kind of all the normal types, who have values, and which can be the argument or return type of a function. <code>* -&gt; *</code> is the kind of simple type formers like <code>Maybe</code>, or <code>Tree</code>, or the list type. These are also called <em>type constructors</em>. Some have more than one argument, e.g. <code>Either</code> has kind <code>* -&gt; * -&gt; *</code>. GHCi happily tells you the kind of a type constructor using the <code>:kind</code> command:</p>
<pre><code>Prelude&gt; :kind Bool
Bool :: *
Prelude&gt; :kind Maybe
Maybe :: * -&gt; *
Prelude&gt; :kind Either
Either :: * -&gt; * -&gt; *</code></pre>
<p>In mundane code, kinds do not get more complicated than that, but there are good uses for higher kinds, such as</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb167-1" title="1"><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</a>
<a class="sourceLine" id="cb167-2" title="2"><span class="co">-- Kind of Fix:</span></a>
<a class="sourceLine" id="cb167-3" title="3"><span class="co">-- Fix :: (* -&gt; *) -&gt; *</span></a></code></pre></div>
<p>Type classes also have a kind, only these do not construct types of kind <code>*</code>, but rather of kind <code>Constraint</code>:</p>
<pre><code>Prelude&gt; :kind Eq
Eq :: * -&gt; Constraint
Prelude&gt; :kind Monoid
Monoid :: * -&gt; Constraint</code></pre>
</section>
<section id="common-pre-defined-type-classes" class="level2">
<h2><span class="header-section-number">4.6</span> Common pre-defined type classes ★</h2>
<p>You should know the following common type classes. Follow the links for a list of methods and other documentation:</p>
<ul>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Eq"><code>Eq</code></a>: Equality (or equivalence)</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Ord"><code>Ord</code></a>: Ordering</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Num"><code>Num</code></a>: Numeric operations (<code>(+)</code>, <code>(-)</code>, <code>(*)</code> and others). There are more numerical type classes (<code>Real</code>, <code>Integral</code>, <code>Fractional</code>, <code>RealFloat</code>).</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Show"><code>Show</code></a>: Provides <code>show :: Show a =&gt; a -&gt; String</code> to serialize a value to a textual representation that is (supposed to be) valid source code. Should be used for debugging mostly, or to convert numbers to strings.</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Read"><code>Read</code></a>: Provides <code>read :: Read a =&gt; String -&gt; a</code>, which goes the other way. Again, not ideal for production use, but can sometimes be used with <code>Show</code> to scaffold serialization. If you have to use <code>Read</code>, please use <a href="http://hackage.haskell.org/package/base/docs/Text-Read.html#v:readMaybe"><code>readMaybe</code></a>.</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Functor"><code>Functor</code></a>: Provides <code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code>. This type class had kind <code>(* -&gt; *) -&gt; Constraint</code>, i.e. can only be instantiated for type formers like <code>Maybe</code> and the list type. It provides the ability to apply a function to each value within the container (for types that are a container, of sorts).</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Applicative"><code>Applicative</code></a> and <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Monad"><code>Monad</code></a>, also of kind <code>(* -&gt; *) -&gt; Constraint</code>, are used to model effects of sorts, for example to hide bookkeeping (in a parser) or safely allow side-effects (in IO code). These deserve their own chapter.</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Foldable"><code>Foldable</code></a> and <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Traversable"><code>Traversable</code></a>, also of kind <code>(* -&gt; *) -&gt; Constraint</code>, are abstractions over containers where elements can be visited in sequence.</p></li>
</ul>
</section>
</section>
<section id="monads" class="level1">
<h1><span class="header-section-number">5</span> Monads</h1>
<p>Haskell is famous for <em>monads</em>, and to those who are scared by sophisticated sounding words, it is even infamous. Judging by the number of “monad tutorials” and other noise about this topic, these monads must indeed be crazy arcane black magic.</p>
<p>So what’s the deal? What is a monad?</p>
<p>Really, the concept of a monad is surprisingly small. It is a pattern of abstraction, expressed as a type class with merely two essential methods and a small number of laws. That’s it, the rest is just applications. But this small idea turns to be amazingly powerful and expressive.</p>
<p>I can’t help but notice that monads are like burritos: What is a burrito? It is a bunch of protein and seasoning, neatly wrapped in a flour tortilla. That’s it. But with just that knowledge, it is impossible to fully appreciate or recreate the wealth and richness of Mexican cuisine. The idea is simple, but the applications are rich and manifold and require skills.</p>
<p>(Oh, and of course, sometimes a taco would do better than of a burrito. Monads are not always the right tool.)</p>
<p>This is a cute analogy, but it does not help the aspiring Haskell reader. So how to we proceed from here? I offer two choices:</p>
<ul>
<li><p>A quick path to understanding “imperative Haskell code”, i.e. Haskell code that uses the <code>IO</code> monad and <code>do</code> notation, and looks similar to, say, Python code. This path avoids almost all technical details about monads, and simply gives you a way to decipher the syntax.</p></li>
<li><p>A slow path where we actually look at the <code>Monad</code> type class, the idea behind it, and some of the more advanced (but still common) applications of it.</p></li>
</ul>
<section id="imperative-code-with-do-notation" class="level2">
<h2><span class="header-section-number">5.1</span> Imperative code with <code>do</code> notation</h2>
<p><strong>Beware:</strong> This section is full of half-truths and glossing over technical details. Imagine plenty of “it looks as if” and “one can think of this as” sprinkled throughout it. Nevertheless, it is useful, though, to get you started.</p>
<p>Previously we said that Haskell functions are pure functions in the mathematical sense: Given some input, they calculate some output, but nothing else can happen, and nothing besides the arguments can influence the result. This is great, but how can Haskell programs then write to files, or respond to network requests, or come up with random numbers?</p>
<p>The solution are <code>IO</code>-functions. These functions can be <em>executed</em>, and when such a function is executed, it can do all these nasty things, before returning a value. Here is a selection of <code>IO</code>-functions available by default:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb169-1" title="1"><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb169-2" title="2"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb169-3" title="3"></a>
<a class="sourceLine" id="cb169-4" title="4"><span class="fu">readFile</span><span class="ot"> ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb169-5" title="5"><span class="fu">writeFile</span><span class="ot"> ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>You can see that these functions may have arguments, just as normal functions. The important bit is the return type, which is <code>IO Something</code>. This indicates that these functions can be executed, and that they have to be executed before we get our hands on the result.</p>
<p>Not all functions have an interesting result (e.g. <code>putStrLn</code> does not); this is where the unit type comes in handy.</p>
<section id="the-main-function-and-do-notation" class="level3">
<h3><span class="header-section-number">5.1.1</span> The <code>main</code> function and <code>do</code> notation</h3>
<p>To execute these functions, we have to use a special syntax, called <code>do</code>-notation, that allows us to write code in an imperative style. Here is an example:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb170-1" title="1">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb170-2" title="2">    <span class="fu">putStrLn</span> <span class="st">&quot;Which file do you want to copy?&quot;</span></a>
<a class="sourceLine" id="cb170-3" title="3">    from <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb170-4" title="4">    <span class="fu">putStrLn</span> <span class="st">&quot;Where do you want to copy it to?&quot;</span></a>
<a class="sourceLine" id="cb170-5" title="5">    to <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb170-6" title="6">    content <span class="ot">&lt;-</span> <span class="fu">readFile</span> from</a>
<a class="sourceLine" id="cb170-7" title="7">    <span class="fu">putStrLn</span> (<span class="st">&quot;Read &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (<span class="fu">length</span> content) <span class="fu">++</span> <span class="st">&quot; bytes.&quot;</span>)</a>
<a class="sourceLine" id="cb170-8" title="8">    <span class="fu">writeFile</span> to content</a>
<a class="sourceLine" id="cb170-9" title="9">    <span class="fu">putStrLn</span> <span class="st">&quot;Done copying.&quot;</span></a></code></pre></div>
<p>we can compile and run this program, and it indeed copies a file:</p>
<pre><code>$ ghc --make copy.hs
[1 of 1] Compiling Main             ( copy.hs, copy.o )
Linking copy ...
$ ./copy
Which file do you want to copy?
copy.hs
Where do you want to copy it to?
copy2.hs
Read 287 bytes.
Done copying.
$ diff copy.hs copy2.hs</code></pre>
<p>Looking at the code, it doesn’t look much different than the equivalent in a language like C or Python. Things to notice:</p>
<ul>
<li>The <code>main</code> function of a module is special. Just like in C, it is the entry point for a compiled Haskell program. When we run the program, then the <code>main</code> function is executed. This is the only way to start executing <code>IO</code>-functions – we cannot do that just nilly-willy within other code.</li>
<li>The body of the <code>main</code> function is written as a <code>do</code> block, which clearly signposts the imperative nature of this code: It is a sequence of things to <code>do</code>.</li>
<li>Every line below the <code>do</code> block is one execution of an <code>IO</code>-function. The first one, for example, prints a question on the terminal.</li>
<li>Some of these <code>IO</code>-functions return values that we want to use later on. These we <em>bind</em> to variables, using the <code>&lt;-</code> syntax. (The last line of a <code>do</code> block is never such a binding, can you imagine why?)</li>
<li>The <code>main</code> function has type <code>IO ()</code>. So it one of these <code>IO</code>-functions as well.</li>
</ul>
</section>
<section id="writing-io-functions" class="level3">
<h3><span class="header-section-number">5.1.2</span> Writing <code>IO</code> functions</h3>
<p>We do not only want to execute <code>IO</code> functions, but also define our own. This is not hard, and we have actually seen that before – the <code>main</code> function is one. We can add parameters without further problems:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb172-1" title="1"><span class="ot">copyFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb172-2" title="2">copyFile from to <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb172-3" title="3">    content <span class="ot">&lt;-</span> <span class="fu">readFile</span> from</a>
<a class="sourceLine" id="cb172-4" title="4">    <span class="fu">putStrLn</span> (<span class="st">&quot;Read &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (<span class="fu">length</span> content) <span class="fu">++</span> <span class="st">&quot; bytes.&quot;</span>)</a>
<a class="sourceLine" id="cb172-5" title="5">    <span class="fu">writeFile</span> to content</a>
<a class="sourceLine" id="cb172-6" title="6"></a>
<a class="sourceLine" id="cb172-7" title="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb172-8" title="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb172-9" title="9">    <span class="fu">putStrLn</span> <span class="st">&quot;Which file do you want to copy?&quot;</span></a>
<a class="sourceLine" id="cb172-10" title="10">    from <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb172-11" title="11">    <span class="fu">putStrLn</span> <span class="st">&quot;Where do you want to copy it to?&quot;</span></a>
<a class="sourceLine" id="cb172-12" title="12">    to <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb172-13" title="13">    copyFile from to</a>
<a class="sourceLine" id="cb172-14" title="14">    <span class="fu">putStrLn</span> <span class="st">&quot;Done copying.&quot;</span></a></code></pre></div>
<p>All our knowledge about defining functions – parameters, pattern matching, recursion – applies here as well.</p>
</section>
<section id="the-return-function" class="level3">
<h3><span class="header-section-number">5.1.3</span> The <code>return</code> function</h3>
<p>The last <code>IO</code> function executed in a <code>do</code> block of an <code>IO</code> function also determines its return value. Therefore we need the little function</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb173-1" title="1"><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>if, at the end of an <code>IO</code> function, we <em>only</em> want to return something:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb174-1" title="1"><span class="ot">fileSize ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb174-2" title="2">fileSize path <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb174-3" title="3">  content <span class="ot">&lt;-</span> <span class="fu">readFile</span> path</a>
<a class="sourceLine" id="cb174-4" title="4">  <span class="fu">return</span> (<span class="fu">length</span> content)</a></code></pre></div>
<p><strong>Important:</strong> Note that <code>return</code> does <em>not</em> alter the control flow. It does not make the function return. It merely specifies the return values of the current <em>line</em>.</p>
<div class="Exercise">
<p>What does this program print?</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb175-1" title="1"><span class="ot">theAnswer ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb175-2" title="2">theAnswer <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb175-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;Pondering the question...&quot;</span></a>
<a class="sourceLine" id="cb175-4" title="4">  <span class="fu">return</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb175-5" title="5">  <span class="fu">return</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb175-6" title="6"></a>
<a class="sourceLine" id="cb175-7" title="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb175-8" title="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb175-9" title="9">  a <span class="ot">&lt;-</span> theAnswer</a>
<a class="sourceLine" id="cb175-10" title="10">  <span class="fu">putStrLn</span> (<span class="fu">show</span> a)</a></code></pre></div>
</div>
<div class="Solution">
<pre><code>Pondering the question...
42</code></pre>
<p>The line <code>return 23</code> doesn’t do anything: There is no side-effect, and the result (the value <code>23</code>) is not bound to any variable and hence ignored.</p>
</div>
</section>
<section id="passing-io-functions-around" class="level3">
<h3><span class="header-section-number">5.1.4</span> Passing <code>IO</code> functions around</h3>
<p>Just passing arguments to <code>copyFile</code> does not actually do anything: we really have to execute it, and execution happens when a function is executed from <code>main</code> (directly or indirectly). Let me demonstrate this point:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb177-1" title="1"><span class="ot">copyFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb177-2" title="2">copyFile from to <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb177-3" title="3">    content <span class="ot">&lt;-</span> <span class="fu">readFile</span> from</a>
<a class="sourceLine" id="cb177-4" title="4">    <span class="fu">putStrLn</span> (<span class="st">&quot;Read &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (<span class="fu">length</span> content) <span class="fu">++</span> <span class="st">&quot; bytes.&quot;</span>)</a>
<a class="sourceLine" id="cb177-5" title="5">    <span class="fu">writeFile</span> to content</a>
<a class="sourceLine" id="cb177-6" title="6"></a>
<a class="sourceLine" id="cb177-7" title="7"><span class="ot">ignore ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb177-8" title="8">ignore unused <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;I ignore my argument!&quot;</span></a>
<a class="sourceLine" id="cb177-9" title="9"></a>
<a class="sourceLine" id="cb177-10" title="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb177-11" title="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb177-12" title="12">    <span class="fu">putStrLn</span> <span class="st">&quot;Which file do you want to copy?&quot;</span></a>
<a class="sourceLine" id="cb177-13" title="13">    from <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb177-14" title="14">    <span class="fu">putStrLn</span> <span class="st">&quot;Where do you want to copy it to?&quot;</span></a>
<a class="sourceLine" id="cb177-15" title="15">    to <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb177-16" title="16">    ignore (copyFile from to)</a>
<a class="sourceLine" id="cb177-17" title="17">    <span class="fu">putStrLn</span> <span class="st">&quot;Done copying.&quot;</span></a></code></pre></div>
<p>Executing this program will ask for the filenames, but it will not actually copy anything. This is because although we passed all arguments to <code>copyFile</code>, we did not actually execute it.</p>
<p>That said, the problem was not that we passed <code>copyFile from to</code> as an argument to a function. Rather, the problem was that <code>ignore</code> did not do anything with it. We can fix that easily (and rename the function to <code>don'tignore</code> along the way):</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb178-1" title="1"><span class="ot">copyFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb178-2" title="2">copyFile from to <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb178-3" title="3">    content <span class="ot">&lt;-</span> <span class="fu">readFile</span> from</a>
<a class="sourceLine" id="cb178-4" title="4">    <span class="fu">putStrLn</span> (<span class="st">&quot;Read &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (<span class="fu">length</span> content) <span class="fu">++</span> <span class="st">&quot; bytes.&quot;</span>)</a>
<a class="sourceLine" id="cb178-5" title="5">    <span class="fu">writeFile</span> to content</a>
<a class="sourceLine" id="cb178-6" title="6"></a>
<a class="sourceLine" id="cb178-7" title="7"><span class="ot">don&#39;tignore ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb178-8" title="8">don&#39;tignore action <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb178-9" title="9">    <span class="fu">putStrLn</span> <span class="st">&quot;About to execute the action.&quot;</span></a>
<a class="sourceLine" id="cb178-10" title="10">    action</a>
<a class="sourceLine" id="cb178-11" title="11">    <span class="fu">putStrLn</span> <span class="st">&quot;I executed the action.&quot;</span></a>
<a class="sourceLine" id="cb178-12" title="12"></a>
<a class="sourceLine" id="cb178-13" title="13"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb178-14" title="14">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb178-15" title="15">    <span class="fu">putStrLn</span> <span class="st">&quot;Which file do you want to copy?&quot;</span></a>
<a class="sourceLine" id="cb178-16" title="16">    from <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb178-17" title="17">    <span class="fu">putStrLn</span> <span class="st">&quot;Where do you want to copy it to?&quot;</span></a>
<a class="sourceLine" id="cb178-18" title="18">    to <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb178-19" title="19">    don&#39;tignore (copyFile from to)</a>
<a class="sourceLine" id="cb178-20" title="20">    <span class="fu">putStrLn</span> <span class="st">&quot;Done copying.&quot;</span></a></code></pre></div>
<p>This way, the <code>copyFile from to</code> function receives its parameters in the <code>main</code> function, but <em>is not yet executed</em>. It is then passed to <code>don'tignore</code>, which does something else first (it prints <code>"About to execute the action."</code>), and <em>then</em> executes the action.</p>
<pre><code>$ ./copy
Which file do you want to copy?
copy.hs
Where do you want to copy it to?
copy2.hs
About to execute the action.
Read 549 bytes.
I executed the action.
Done copying.</code></pre>
<p>Being able to abstract over <code>IO</code>-functions just like over anything else, and having precise control when they are <em>executed</em> (rather than just passed around), is again a very powerful tool.</p>
<div class="Exercise">
<p>What does this program do?</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb180-1" title="1"><span class="ot">foo ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb180-2" title="2">foo <span class="dv">0</span> a <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;Done&quot;</span></a>
<a class="sourceLine" id="cb180-3" title="3">foo n a <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb180-4" title="4">   <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">1</span> <span class="kw">then</span> <span class="fu">putStrLn</span> <span class="st">&quot;Almost done&quot;</span></a>
<a class="sourceLine" id="cb180-5" title="5">             <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb180-6" title="6">   a</a>
<a class="sourceLine" id="cb180-7" title="7">   foo (n<span class="fu">-</span><span class="dv">1</span>) a</a>
<a class="sourceLine" id="cb180-8" title="8"></a>
<a class="sourceLine" id="cb180-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb180-10" title="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb180-11" title="11">   foo <span class="dv">4</span> (<span class="fu">putStrLn</span> <span class="st">&quot;Hooray!&quot;</span>)</a>
<a class="sourceLine" id="cb180-12" title="12">   foo <span class="dv">0</span> (<span class="fu">putStrLn</span> <span class="st">&quot;And up she rises.&quot;</span>)</a></code></pre></div>
</div>
<div class="Solution">
<pre><code>Hooray!
Hooray!
Hooray!
Almost done
Hooray!
Done
Done</code></pre>
<p>Note that the <code>putStrLn "And up she rises."</code> is never executed.</p>
</div>
</section>
<section id="let-expressions-in-do-blocks" class="level3">
<h3><span class="header-section-number">5.1.5</span> <code>let</code> expressions in <code>do</code> blocks ★</h3>
<p>You can use <code>let</code> expressions in do blocks, omitting the <code>in</code>. These work like normal <code>let</code> expressions, i.e. simply give a name to an expression:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb182-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb182-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb182-3" title="3">    <span class="fu">putStrLn</span> <span class="st">&quot;Which file do you want to copy?&quot;</span></a>
<a class="sourceLine" id="cb182-4" title="4">    from <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb182-5" title="5">    <span class="kw">let</span> to <span class="fu">=</span> from <span class="fu">++</span> <span class="st">&quot;.bak&quot;</span></a>
<a class="sourceLine" id="cb182-6" title="6">    copyFile from to</a>
<a class="sourceLine" id="cb182-7" title="7">    <span class="fu">putStrLn</span> (<span class="st">&quot;Created backup at &quot;</span> <span class="fu">++</span> to)</a></code></pre></div>
<p>Note that it does <em>not</em> execute anything, as this example shows:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb183-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb183-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb183-3" title="3">    <span class="fu">putStrLn</span> <span class="st">&quot;Please press enter.&quot;</span></a>
<a class="sourceLine" id="cb183-4" title="4">    input1 <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb183-5" title="5">    <span class="fu">putStrLn</span> <span class="st">&quot;Enter pressed.&quot;</span></a>
<a class="sourceLine" id="cb183-6" title="6"></a>
<a class="sourceLine" id="cb183-7" title="7">    <span class="fu">putStrLn</span> <span class="st">&quot;Please press enter.&quot;</span></a>
<a class="sourceLine" id="cb183-8" title="8">    <span class="kw">let</span> input2 <span class="fu">=</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb183-9" title="9">    <span class="fu">putStrLn</span> <span class="st">&quot;Enter pressed.&quot;</span></a></code></pre></div>
<p>If we run this only the first occurrence to <code>getLine</code> actually does something:</p>
<pre><code>$ ghc --make let-do.hs
[1 of 1] Compiling Main             ( let-do.hs, let-do.o )
Linking let-do ...
$ ./let-do
Please press enter.

Enter pressed.
Please press enter.
Enter pressed.</code></pre>
<p>The variable <code>input2</code> is named misleadingly: It does not name any user input, it is now merely an alternative name for the <code>IO</code> function <code>getLine</code>.</p>
</section>
<section id="the-operator" class="level3">
<h3><span class="header-section-number">5.1.6</span> The <code>&lt;$&gt;</code> operator ★</h3>
<p>You will come across code that wants to execute an <code>IO</code> function <em>and</em> apply some normal (pure) function to its result in one go, like the <code>fileSize</code> function above. We can use the <code>&lt;$&gt;</code> operator to write that in one line, without giving a name to the intermediate value:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb185-1" title="1"><span class="ot">fileSize ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb185-2" title="2">fileSize path <span class="fu">=</span> <span class="fu">length</span> <span class="fu">&lt;$&gt;</span> <span class="fu">readFile</span> path</a></code></pre></div>
<p>When reading such code, you can think of <code>&lt;$&gt;</code> as a variant <code>$</code>, but the <em>return value</em> of the expression on the right hand side is passed to the function on the left, rather than the <code>IO</code> function as a whole.</p>
</section>
</section>
<section id="monads-for-real" class="level2">
<h2><span class="header-section-number">5.2</span> Monads, for real</h2>
<p>The previous section we only looked at a facade of monads in Haskell, both in the sense that we went along with how things looked, not how things are, and that there is much more behind. In the remainder of the Chapter, we give a more principled introduction of the concept.</p>
</section>
</section>
</body>
</html>
